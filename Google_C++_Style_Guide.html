<!DOCTYPE html>
<!-- saved from url=(0049)https://google.github.io/styleguide/cppguide.html -->
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <title>Google C++ Style Guide</title>
  <link rel="stylesheet" type="text/css" href="./Google_C++_Style_Guide_files/styleguide.css">
  <script language="javascript" src="./Google_C++_Style_Guide_files/styleguide.js.download"></script>
  <link rel="shortcut icon" type="image/x-icon" href="https://www.google.com/favicon.ico">
</head>

<body onload="initStyleGuide();">
  <div id="content">
    <h1>Google C++ Style Guide</h1>
    <div class="horizontal_toc" id="tocDiv">
      <div class="toc_title"></div>
      <h3 class="ignoreLink" id="toc">Table of Contents</h3>
      <table>
        <tbody valign="top" class="toc">
          <tr valign="top">
            <td>
              <div class="toc_category">
                <a href="https://google.github.io/styleguide/cppguide.html#Header_Files">Header Files</a>
              </div>
            </td>
            <td>
              <div class="toc_stylepoint">
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Self_contained_Headers">Self-contained Headers</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#The__define_Guard">The #define Guard</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Forward_Declarations">Forward Declarations</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Inline_Functions">Inline Functions</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Names_and_Order_of_Includes">Names and Order of Includes</a>
                </li>
              </div>
            </td>
          </tr>
          <tr valign="top">
            <td>
              <div class="toc_category">
                <a href="https://google.github.io/styleguide/cppguide.html#Scoping">Scoping</a>
              </div>
            </td>
            <td>
              <div class="toc_stylepoint">
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Namespaces">Namespaces</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Unnamed_Namespaces_and_Static_Variables">Unnamed Namespaces and Static Variables
                  </a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Nonmember,_Static_Member,_and_Global_Functions">Nonmember, Static Member, and Global Functions</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Local_Variables">Local Variables</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Static_and_Global_Variables">Static and Global Variables</a>
                </li>
              </div>
            </td>
          </tr>
          <tr valign="top">
            <td>
              <div class="toc_category">
                <a href="https://google.github.io/styleguide/cppguide.html#Classes">Classes</a>
              </div>
            </td>
            <td>
              <div class="toc_stylepoint">
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Doing_Work_in_Constructors">Doing Work in Constructors</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Implicit_Conversions">Implicit Conversions</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Copyable_Movable_Types">Copyable and Movable Types</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Structs_vs._Classes">Structs vs. Classes</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Inheritance">Inheritance</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Multiple_Inheritance">Multiple Inheritance</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Interfaces">Interfaces</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Operator_Overloading">Operator Overloading</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Access_Control">Access Control</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Declaration_Order">Declaration Order</a>
                </li>
              </div>
            </td>
          </tr>
          <tr valign="top">
            <td>
              <div class="toc_category">
                <a href="https://google.github.io/styleguide/cppguide.html#Functions">Functions</a>
              </div>
            </td>
            <td>
              <div class="toc_stylepoint">
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Function_Parameter_Ordering">Parameter Ordering</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Write_Short_Functions">Write Short Functions</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Reference_Arguments">Reference Arguments</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Function_Overloading">Function Overloading</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Default_Arguments">Default Arguments</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#trailing_return">Trailing Return Type Syntax</a>
                </li>
              </div>
            </td>
          </tr>
          <tr valign="top">
            <td>
              <div class="toc_category">
                <a href="https://google.github.io/styleguide/cppguide.html#Google-Specific_Magic">Google-Specific Magic</a>
              </div>
            </td>
            <td>
              <div class="toc_stylepoint">
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Ownership_and_Smart_Pointers">Ownership and Smart Pointers</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#cpplint">cpplint</a>
                </li>
              </div>
            </td>
          </tr>
          <tr valign="top">
            <td>
              <div class="toc_category">
                <a href="https://google.github.io/styleguide/cppguide.html#Other_C++_Features">Other C++ Features</a>
              </div>
            </td>
            <td>
              <div class="toc_stylepoint">
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Rvalue_references">Rvalue References</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Friends">Friends</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Exceptions">Exceptions</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Run-Time_Type_Information__RTTI_">Run-Time Type Information (RTTI)</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Casting">Casting</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Streams">Streams</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Preincrement_and_Predecrement">Preincrement and Predecrement</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Use_of_const">Use of const</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Use_of_constexpr">Use of constexpr</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Integer_Types">Integer Types</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#64-bit_Portability">64-bit Portability</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Preprocessor_Macros">Preprocessor Macros</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#0_and_nullptr/NULL">0 and nullptr/NULL</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#sizeof">sizeof</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#auto">auto</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Braced_Initializer_List">Braced Initializer List</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Lambda_expressions">Lambda expressions</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Template_metaprogramming">Template metaprogramming</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Boost">Boost</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#std_hash">std::hash</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#C++11">C++11</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Nonstandard_Extensions">Nonstandard Extensions</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Aliases">Aliases</a>
                </li>
              </div>
            </td>
          </tr>
          <tr valign="top">
            <td>
              <div class="toc_category">
                <a href="https://google.github.io/styleguide/cppguide.html#Naming">Naming</a>
              </div>
            </td>
            <td>
              <div class="toc_stylepoint">
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#General_Naming_Rules">General Naming Rules</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#File_Names">File Names</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Type_Names">Type Names</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Variable_Names">Variable Names</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Constant_Names">Constant Names</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Function_Names">Function Names</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Namespace_Names">Namespace Names</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Enumerator_Names">Enumerator Names</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Macro_Names">Macro Names</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Exceptions_to_Naming_Rules">Exceptions to Naming Rules</a>
                </li>
              </div>
            </td>
          </tr>
          <tr valign="top">
            <td>
              <div class="toc_category">
                <a href="https://google.github.io/styleguide/cppguide.html#Comments">Comments</a>
              </div>
            </td>
            <td>
              <div class="toc_stylepoint">
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Comment_Style">Comment Style</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#File_Comments">File Comments</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Class_Comments">Class Comments</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Function_Comments">Function Comments</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Variable_Comments">Variable Comments</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Implementation_Comments">Implementation Comments</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Punctuation,_Spelling_and_Grammar">Punctuation, Spelling and Grammar</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#TODO_Comments">TODO Comments</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Deprecation_Comments">Deprecation Comments</a>
                </li>
              </div>
            </td>
          </tr>
          <tr valign="top">
            <td>
              <div class="toc_category">
                <a href="https://google.github.io/styleguide/cppguide.html#Formatting">Formatting</a>
              </div>
            </td>
            <td>
              <div class="toc_stylepoint">
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Line_Length">Line Length</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Non-ASCII_Characters">Non-ASCII Characters</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Spaces_vs._Tabs">Spaces vs. Tabs</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Function_Declarations_and_Definitions">Function Declarations and Definitions</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Formatting_Lambda_Expressions">Lambda Expressions</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Function_Calls">Function Calls</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Braced_Initializer_List_Format">Braced Initializer List Format</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Conditionals">Conditionals</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Loops_and_Switch_Statements">Loops and Switch Statements</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Pointer_and_Reference_Expressions">Pointer and Reference Expressions</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Boolean_Expressions">Boolean Expressions</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Return_Values">Return Values</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Variable_and_Array_Initialization">Variable and Array Initialization</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Preprocessor_Directives">Preprocessor Directives</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Class_Format">Class Format</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Constructor_Initializer_Lists">Constructor Initializer Lists</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Namespace_Formatting">Namespace Formatting</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Horizontal_Whitespace">Horizontal Whitespace</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Vertical_Whitespace">Vertical Whitespace</a>
                </li>
              </div>
            </td>
          </tr>
          <tr valign="top">
            <td>
              <div class="toc_category">
                <a href="https://google.github.io/styleguide/cppguide.html#Exceptions_to_the_Rules">Exceptions to the Rules</a>
              </div>
            </td>
            <td>
              <div class="toc_stylepoint">
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Existing_Non-conformant_Code">Existing Non-conformant Code</a>
                </li>
                <li class="toc_entry">
                  <a href="https://google.github.io/styleguide/cppguide.html#Windows_Code">Windows Code</a>
                </li>
              </div>
            </td>
          </tr>
        </tbody>
      </table>
      <div class="toc_title"></div>
      <h3 class="ignoreLink" id="toc">Table of Contents</h3>
      <table>
        <tbody valign="top" class="toc"></tbody>
      </table>
    </div>

    <div class="main_body">

      <h2 class="ignoreLink" id="Background">Background</h2>

      <p>C++ is one of the main development languages used by many of Google's open-source projects. As
        every C++ programmer knows, the language has many powerful features, but this power brings with
        it complexity, which in turn can make code more bug-prone and harder to read and maintain.</p>

      <p>The goal of this guide is to manage this complexity by describing in detail the dos and don'ts
        of writing C++ code. These rules exist to keep the code base manageable while still allowing
        coders to use C++ language features productively.</p>

      <p>
        <em>Style</em>, also known as readability, is what we call the conventions that govern our C++ code.
        The term Style is a bit of a misnomer, since these conventions cover far more than just source
        file formatting.</p>

      <p>
        Most open-source projects developed by Google conform to the requirements in this guide.
      </p>





      <p>Note that this guide is not a C++ tutorial: we assume that the reader is familiar with the language.
        </p>

      <h3 id="Goals" style="left: -46px; position: relative;">Goals of the Style Guide
        <a href="https://google.github.io/styleguide/cppguide.html#Goals" alt="link to Goals">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Goals" alt="link to Goals">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>
      <div class="stylebody">
        <p>Why do we have this document?</p>

        <p>There are a few core goals that we believe this guide should serve. These are the fundamental
          <b>why</b>s that underlie all of the individual rules. By bringing these ideas to the fore, we
          hope to ground discussions and make it clearer to our broader community why the rules are in
          place and why particular decisions have been made. If you understand what goals each rule is
          serving, it should be clearer to everyone when a rule may be waived (some can be), and what
          sort of argument or alternative would be necessary to change a rule in the guide.</p>

        <p>The goals of the style guide as we currently see them are as follows:</p>
        <dl>
          <dt>Style rules should pull their weight</dt>
          <dd>The benefit of a style rule must be large enough to justify asking all of our engineers to
            remember it. The benefit is measured relative to the codebase we would get without the rule,
            so a rule against a very harmful practice may still have a small benefit if people are unlikely
            to do it anyway. This principle mostly explains the rules we don’t have, rather than the
            rules we do: for example,
            <code>goto</code> contravenes many of the following principles, but is already vanishingly rare, so the Style
            Guide doesn’t discuss it.</dd>

          <dt>Optimize for the reader, not the writer</dt>
          <dd>Our codebase (and most individual components submitted to it) is expected to continue for quite
            some time. As a result, more time will be spent reading most of our code than writing it.
            We explicitly choose to optimize for the experience of our average software engineer reading,
            maintaining, and debugging code in our codebase rather than ease when writing said code.
            "Leave a trace for the reader" is a particularly common sub-point of this principle: When
            something surprising or unusual is happening in a snippet of code (for example, transfer
            of pointer ownership), leaving textual hints for the reader at the point of use is valuable
            (
            <code>std::unique_ptr</code> demonstrates the ownership transfer unambiguously at the call site). </dd>

          <dt>Be consistent with existing code</dt>
          <dd>Using one style consistently through our codebase lets us focus on other (more important) issues.
            Consistency also allows for automation: tools that format your code or adjust your
            <code>#include</code>s only work properly when your code is consistent with the expectations of the tooling. In
            many cases, rules that are attributed to "Be Consistent" boil down to "Just pick one and
            stop worrying about it"; the potential value of allowing flexibility on these points is outweighed
            by the cost of having people argue over them. </dd>

          <dt>Be consistent with the broader C++ community when appropriate</dt>
          <dd>Consistency with the way other organizations use C++ has value for the same reasons as consistency
            within our code base. If a feature in the C++ standard solves a problem, or if some idiom
            is widely known and accepted, that's an argument for using it. However, sometimes standard
            features and idioms are flawed, or were just designed without our codebase's needs in mind.
            In those cases (as described below) it's appropriate to constrain or ban standard features.
            In some cases we prefer a homegrown or third-party library over a library defined in the
            C++ Standard, either out of perceived superiority or insufficient value to transition the
            codebase to the standard interface.</dd>

          <dt>Avoid surprising or dangerous constructs</dt>
          <dd>C++ has features that are more surprising or dangerous than one might think at a glance. Some
            style guide restrictions are in place to prevent falling into these pitfalls. There is a
            high bar for style guide waivers on such restrictions, because waiving such rules often directly
            risks compromising program correctness.
          </dd>

          <dt>Avoid constructs that our average C++ programmer would find tricky or hard to maintain</dt>
          <dd>C++ has features that may not be generally appropriate because of the complexity they introduce
            to the code. In widely used code, it may be more acceptable to use trickier language constructs,
            because any benefits of more complex implementation are multiplied widely by usage, and the
            cost in understanding the complexity does not need to be paid again when working with new
            portions of the codebase. When in doubt, waivers to rules of this type can be sought by asking
            your project leads. This is specifically important for our codebase because code ownership
            and team membership changes over time: even if everyone that works with some piece of code
            currently understands it, such understanding is not guaranteed to hold a few years from now.</dd>

          <dt>Be mindful of our scale</dt>
          <dd>With a codebase of 100+ million lines and thousands of engineers, some mistakes and simplifications
            for one engineer can become costly for many. For instance it's particularly important to
            avoid polluting the global namespace: name collisions across a codebase of hundreds of millions
            of lines are difficult to work with and hard to avoid if everyone puts things into the global
            namespace.
          </dd>

          <dt>Concede to optimization when necessary</dt>
          <dd>Performance optimizations can sometimes be necessary and appropriate, even when they conflict
            with the other principles of this document.
          </dd>
        </dl>

        <p>The intent of this document is to provide maximal guidance with reasonable restriction. As always,
          common sense and good taste should prevail. By this we specifically refer to the established
          conventions of the entire Google C++ community, not just your personal preferences or those
          of your team. Be skeptical about and reluctant to use clever or unusual constructs: the absence
          of a prohibition is not the same as a license to proceed. Use your judgment, and if you are
          unsure, please don't hesitate to ask your project leads to get additional input.
        </p>

      </div>



      <h2 id="Header_Files" style="left: -46px; position: relative;">Header Files
        <a href="https://google.github.io/styleguide/cppguide.html#Header_Files" alt="link to Header_Files">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Header_Files"
          alt="link to Header_Files">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h2>

      <p>In general, every
        <code>.cc</code> file should have an associated
        <code>.h</code> file. There are some common exceptions, such as unittests and small
        <code>.cc</code> files containing just a
        <code>main()</code> function.</p>

      <p>Correct use of header files can make a huge difference to the readability, size and performance
        of your code.</p>

      <p>The following rules will guide you through the various pitfalls of using header files.</p>

      <a id="The_-inl.h_Files"></a>
      <h3 id="Self_contained_Headers" style="left: -46px; position: relative;">Self-contained Headers
        <a href="https://google.github.io/styleguide/cppguide.html#Self_contained_Headers"
          alt="link to Self_contained_Headers">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Self_contained_Headers"
          alt="link to Self_contained_Headers">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Header files should be self-contained (compile on their own) and end in
          <code>.h</code>. Non-header files that are meant for inclusion should end in
          <code>.inc</code> and be used sparingly.</p>
      </div>

      <div class="stylebody">
        <p>All header files should be self-contained. Users and refactoring tools should not have to adhere
          to special conditions to include the header. Specifically, a header should have
          <a href="https://google.github.io/styleguide/cppguide.html#The__define_Guard">header guards</a> and include all other headers it needs.</p>

        <p>Prefer placing the definitions for template and inline functions in the same file as their declarations.
          The definitions of these constructs must be included into every
          <code>.cc</code> file that uses them, or the program may fail to link in some build configurations. If declarations
          and definitions are in different files, including the former should transitively include the
          latter. Do not move these definitions to separately included header files (
          <code>-inl.h</code>); this practice was common in the past, but is no longer allowed.</p>

        <p>As an exception, a template that is explicitly instantiated for all relevant sets of template
          arguments, or that is a private implementation detail of a class, is allowed to be defined
          in the one and only
          <code>.cc</code> file that instantiates the template.</p>

        <p>There are rare cases where a file designed to be included is not self-contained. These are typically
          intended to be included at unusual locations, such as the middle of another file. They might
          not use
          <a href="https://google.github.io/styleguide/cppguide.html#The__define_Guard">header guards</a>, and might not include their prerequisites. Name such files with the
          <code>.inc</code> extension. Use sparingly, and prefer self-contained headers when possible.
        </p>

      </div>

      <h3 id="The__define_Guard" style="left: -46px; position: relative;">The #define Guard
        <a href="https://google.github.io/styleguide/cppguide.html#The__define_Guard"
          alt="link to The__define_Guard">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#The__define_Guard"
          alt="link to The__define_Guard">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>All header files should have
          <code>#define</code> guards to prevent multiple inclusion. The format of the symbol name should be
          <code><i>&lt;PROJECT&gt;</i>_<i>&lt;PATH&gt;</i>_<i>&lt;FILE&gt;</i>_H_</code>.</p>
      </div>

      <div class="stylebody">



        <p>To guarantee uniqueness, they should be based on the full path in a project's source tree. For
          example, the file
          <code>foo/src/bar/baz.h</code> in project
          <code>foo</code> should have the following guard:
        </p>

        <pre>#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_

...

#endif  // FOO_BAR_BAZ_H_
</pre>




      </div>

      <h3 id="Forward_Declarations" style="left: -46px; position: relative;">Forward Declarations
        <a href="https://google.github.io/styleguide/cppguide.html#Forward_Declarations"
          alt="link to Forward_Declarations">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Forward_Declarations"
          alt="link to Forward_Declarations">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Avoid using forward declarations where possible. Just
          <code>#include</code> the headers you need.</p>
      </div>

      <div class="stylebody">

        <div class="definition">
          <p>A "forward declaration" is a declaration of a class, function, or template without an associated
            definition.</p>
        </div>

        <div class="pros">
          <ul>
            <li>Forward declarations can save compile time, as
              <code>#include</code>s force the compiler to open more files and process more input.</li>

            <li>Forward declarations can save on unnecessary recompilation.
              <code>#include</code>s can force your code to be recompiled more often, due to unrelated changes in the header.</li>
          </ul>
        </div>

        <div class="cons">
          <ul>
            <li>Forward declarations can hide a dependency, allowing user code to skip necessary recompilation
              when headers change.
            </li>

            <li>A forward declaration may be broken by subsequent changes to the library. Forward declarations
              of functions and templates can prevent the header owners from making otherwise-compatible
              changes to their APIs, such as widening a parameter type, adding a template parameter with
              a default value, or migrating to a new namespace.</li>

            <li>Forward declaring symbols from namespace
              <code>std::</code> yields undefined behavior.</li>

            <li>It can be difficult to determine whether a forward declaration or a full
              <code>#include</code> is needed. Replacing an
              <code>#include</code> with a forward declaration can silently change the meaning of code:
              <pre>      // b.h:
      struct B {};
      struct D : B {};

      // good_user.cc:
      #include "b.h"
      void f(B*);
      void f(void*);
      void test(D* x) { f(x); }  // calls f(B*)
      </pre> If the
              <code>#include</code> was replaced with forward decls for
              <code>B</code> and
              <code>D</code>,
              <code>test()</code> would call
              <code>f(void*)</code>.
            </li>

            <li>Forward declaring multiple symbols from a header can be more verbose than simply
              <code>#include</code>ing the header.</li>

            <li>Structuring code to enable forward declarations (e.g. using pointer members instead of object
              members) can make the code slower and more complex.</li>


          </ul>
        </div>

        <div class="decision">
          <ul>
            <li>Try to avoid forward declarations of entities defined in another project.</li>

            <li>When using a function declared in a header file, always
              <code>#include</code> that header.</li>

            <li>When using a class template, prefer to
              <code>#include</code> its header file.</li>
          </ul>

          <p>Please see
            <a href="https://google.github.io/styleguide/cppguide.html#Names_and_Order_of_Includes">Names and Order of Includes</a> for rules about when to #include a header.</p>
        </div>

      </div>

      <h3 id="Inline_Functions" style="left: -46px; position: relative;">Inline Functions
        <a href="https://google.github.io/styleguide/cppguide.html#Inline_Functions" alt="link to Inline_Functions">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Inline_Functions"
          alt="link to Inline_Functions">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Define functions inline only when they are small, say, 10 lines or fewer.</p>
      </div>

      <div class="stylebody">

        <div class="definition">
          <p>You can declare functions in a way that allows the compiler to expand them inline rather than
            calling them through the usual function call mechanism.</p>
        </div>

        <div class="pros">
          <p>Inlining a function can generate more efficient object code, as long as the inlined function
            is small. Feel free to inline accessors and mutators, and other short, performance-critical
            functions.</p>
        </div>

        <div class="cons">
          <p>Overuse of inlining can actually make programs slower. Depending on a function's size, inlining
            it can cause the code size to increase or decrease. Inlining a very small accessor function
            will usually decrease code size while inlining a very large function can dramatically increase
            code size. On modern processors smaller code usually runs faster due to better use of the
            instruction cache.</p>
        </div>

        <div class="decision">
          <p>A decent rule of thumb is to not inline a function if it is more than 10 lines long. Beware
            of destructors, which are often longer than they appear because of implicit member- and base-destructor
            calls!</p>

          <p>Another useful rule of thumb: it's typically not cost effective to inline functions with loops
            or switch statements (unless, in the common case, the loop or switch statement is never executed).</p>

          <p>It is important to know that functions are not always inlined even if they are declared as
            such; for example, virtual and recursive functions are not normally inlined. Usually recursive
            functions should not be inline. The main reason for making a virtual function inline is to
            place its definition in the class, either for convenience or to document its behavior, e.g.,
            for accessors and mutators.
          </p>
        </div>

      </div>

      <h3 id="Names_and_Order_of_Includes" style="left: -46px; position: relative;">Names and Order of Includes
        <a href="https://google.github.io/styleguide/cppguide.html#Names_and_Order_of_Includes"
          alt="link to Names_and_Order_of_Includes">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Names_and_Order_of_Includes"
          alt="link to Names_and_Order_of_Includes">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Use standard order for readability and to avoid hidden dependencies: Related header, C library,
          C++ library, other libraries'
          <code>.h</code>, your project's
          <code>.h</code>.</p>
      </div>

      <div class="stylebody">
        <p>
          All of a project's header files should be listed as descendants of the project's source directory without
          use of UNIX directory shortcuts
          <code>.</code> (the current directory) or
          <code>..</code> (the parent directory). For example,

          <code>google-awesome-project/src/base/logging.h</code> should be included as:</p>

        <pre>#include "base/logging.h"
</pre>

        <p>In
          <code><var>dir/foo</var>.cc</code> or
          <code><var>dir/foo_test</var>.cc</code>, whose main purpose is to implement or test the stuff in
          <code><var>dir2/foo2</var>.h</code>, order your includes as follows:</p>

        <ol>
          <li>
            <code><var>dir2/foo2</var>.h</code>.</li>

          <li>C system files.</li>

          <li>C++ system files.</li>

          <li>Other libraries'
            <code>.h</code> files.
          </li>

          <li>
            Your project's
            <code>.h</code> files.
          </li>
        </ol>

        <p>With the preferred ordering, if
          <code><var>dir2/foo2</var>.h</code> omits any necessary includes, the build of
          <code><var>dir/foo</var>.cc</code> or
          <code><var>dir/foo</var>_test.cc</code> will break. Thus, this rule ensures that build breaks show up first for the people working
          on these files, not for innocent people in other packages.</p>

        <p>
          <code><var>dir/foo</var>.cc</code> and
          <code><var>dir2/foo2</var>.h</code> are usually in the same directory (e.g.
          <code>base/basictypes_test.cc</code> and
          <code>base/basictypes.h</code>), but may sometimes be in different directories too.</p>



        <p>Within each section the includes should be ordered alphabetically. Note that older code might
          not conform to this rule and should be fixed when convenient.</p>

        <p>You should include all the headers that define the symbols you rely upon, except in the unusual
          case of
          <a href="https://google.github.io/styleguide/cppguide.html#Forward_Declarations">forward declaration
          </a>. If you rely on symbols from
          <code>bar.h</code>, don't count on the fact that you included
          <code>foo.h</code> which (currently) includes
          <code>bar.h</code>: include
          <code>bar.h</code> yourself, unless
          <code>foo.h</code> explicitly demonstrates its intent to provide you the symbols of
          <code>bar.h</code>. However, any includes present in the related header do not need to be included again in the
          related
          <code>cc</code> (i.e.,
          <code>foo.cc</code> can rely on
          <code>foo.h</code>'s includes).</p>

        <p>For example, the includes in

          <code>google-awesome-project/src/foo/internal/fooserver.cc</code> might look like this:</p>


        <pre>#include "foo/server/fooserver.h"

#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

#include &lt;hash_map&gt;
#include &lt;vector&gt;

#include "base/basictypes.h"
#include "base/commandlineflags.h"
#include "foo/server/bar.h"
</pre>

        <p class="exception">Sometimes, system-specific code needs conditional includes. Such code can put conditional includes
          after other includes. Of course, keep your system-specific code small and localized. Example:</p>

        <pre>#include "foo/public/fooserver.h"

#include "base/port.h"  // For LANG_CXX11.

#ifdef LANG_CXX11
#include &lt;initializer_list&gt;
#endif  // LANG_CXX11
</pre>

      </div>

      <h2 id="Scoping" style="left: -46px; position: relative;">Scoping
        <a href="https://google.github.io/styleguide/cppguide.html#Scoping" alt="link to Scoping">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h2>

      <h3 id="Namespaces" style="left: -46px; position: relative;">Namespaces
        <a href="https://google.github.io/styleguide/cppguide.html#Namespaces" alt="link to Namespaces">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="stylebody">
        <div class="decision">
          <p>Namespaces should be used as follows:</p>

          <ul>
            <li>Follow the rules on
              <a href="https://google.github.io/styleguide/cppguide.html#Namespace_Names">Namespace Names</a>.
            </li>
            <li>Terminate namespaces with comments as shown in the given examples.
            </li>
            <li>

              <p>Namespaces wrap the entire source file after includes,
                <a href="https://gflags.github.io/gflags/">
                  gflags</a> definitions/declarations and forward declarations of classes from other
                namespaces.</p>

              <pre>
// In the .h file
namespace mynamespace {

// All declarations are within the namespace scope.
// Notice the lack of indentation.
class MyClass {
 public:
  ...
  void Foo();
};

}  // namespace mynamespace
</pre>

              <pre>// In the .cc file
namespace mynamespace {

// Definition of functions is within scope of the namespace.
void MyClass::Foo() {
  ...
}

}  // namespace mynamespace
</pre>

              <p>More complex
                <code>.cc</code> files might have additional details, like flags or using-declarations.</p>

              <pre>#include "a.h"

DEFINE_FLAG(bool, someflag, false, "dummy flag");

namespace a {

using ::foo::bar;

...code for a...         // Code goes against the left margin.

}  // namespace a
</pre>
            </li>

            <li>
              <p>You may not use a
                <i>using-directive</i>
                to make all names from a namespace available.</p>

              <pre class="badcode">// Forbidden -- This pollutes the namespace.
using namespace foo;
</pre>
            </li>

            <li>
              <p>Do not use
                <i>Namespace aliases</i> at namespace scope in header files except in explicitly marked
                internal-only namespaces, because anything imported into a namespace in a header file
                becomes part of the public API exported by that file.</p>

              <pre>// Shorten access to some commonly used names in .cc files.
namespace baz = ::foo::bar::baz;
</pre>

              <pre>// Shorten access to some commonly used names (in a .h file).
namespace librarian {
namespace impl {  // Internal, not part of the API.
namespace sidetable = ::pipeline_diagnostics::sidetable;
}  // namespace impl

inline void my_inline_function() {
  // namespace alias local to a function (or method).
  namespace baz = ::foo::bar::baz;
  ...
}
}  // namespace librarian
</pre>

            </li>
            <li>Do not use inline namespaces.</li>
          </ul>
        </div>
      </div>

      <h3 id="Local_Variables" style="left: -46px; position: relative;">Local Variables
        <a href="https://google.github.io/styleguide/cppguide.html#Local_Variables" alt="link to Local_Variables">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Place a function's variables in the narrowest scope possible, and initialize variables in the
          declaration.</p>
      </div>

      <div class="stylebody">

        <p>C++ allows you to declare variables anywhere in a function. We encourage you to declare them
          in as local a scope as possible, and as close to the first use as possible. This makes it easier
          for the reader to find the declaration and see what type the variable is and what it was initialized
          to. In particular, initialization should be used instead of declaration and assignment, e.g.:</p>

        <pre class="badcode">int i;
i = f();      // Bad -- initialization separate from declaration.
</pre>

        <pre>int j = g();  // Good -- declaration has initialization.
</pre>

        <pre class="badcode">std::vector&lt;int&gt; v;
v.push_back(1);  // Prefer initializing using brace initialization.
v.push_back(2);
</pre>

        <pre>std::vector&lt;int&gt; v = {1, 2};  // Good -- v starts initialized.
</pre>

        <p>Variables needed for
          <code>if</code>,
          <code>while</code> and
          <code>for</code> statements should normally be declared within those statements, so that such variables are
          confined to those scopes. E.g.:</p>

        <pre>while (const char* p = strchr(str, '/')) str = p + 1;
</pre>

        <p>There is one caveat: if the variable is an object, its constructor is invoked every time it enters
          scope and is created, and its destructor is invoked every time it goes out of scope.</p>

        <pre class="badcode">// Inefficient implementation:
for (int i = 0; i &lt; 1000000; ++i) {
  Foo f;  // My ctor and dtor get called 1000000 times each.
  f.DoSomething(i);
}
</pre>

        <p>It may be more efficient to declare such a variable used in a loop outside that loop:</p>

        <pre>Foo f;  // My ctor and dtor get called once each.
for (int i = 0; i &lt; 1000000; ++i) {
  f.DoSomething(i);
}
</pre>

      </div>


      <h2 id="Classes" style="left: -46px; position: relative;">Classes
        <a href="https://google.github.io/styleguide/cppguide.html#Classes" alt="link to Classes">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h2>

      <p>Classes are the fundamental unit of code in C++. Naturally, we use them extensively. This section
        lists the main dos and don'ts you should follow when writing a class.</p>

      <h3 id="Structs_vs._Classes" style="left: -46px; position: relative;">Structs vs. Classes
        <a href="https://google.github.io/styleguide/cppguide.html#Structs_vs._Classes"
          alt="link to Structs_vs._Classes">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Use a
          <code>struct</code> only for passive objects that carry data; everything else is a
          <code>class</code>.</p>
      </div>

      <div class="stylebody">

        <p>Note that member variables in structs and classes have
          <a href="https://google.github.io/styleguide/cppguide.html#Variable_Names">different naming rules</a>.</p>

      </div>

      <h3 id="Inheritance" style="left: -46px; position: relative;">Inheritance
        <a href="https://google.github.io/styleguide/cppguide.html#Inheritance" alt="link to Inheritance">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="stylebody">

        <p>Explicitly annotate overrides of virtual functions or virtual destructors
          with an <code>override</code> or (less frequently) <code>final</code>
          specifier. Older (pre-C++11) code will use the <code>virtual</code>
          keyword as an inferior alternative annotation. For clarity, use exactly
          one of <code>override</code>, <code>final</code>, or <code>virtual</code>
          when declaring an override. Rationale: A function or destructor marked
          <code>override</code> or <code>final</code> that is not an override
          of a base class virtual function will not compile, and this helps catch
          common errors. The specifiers serve as documentation; if no specifier
          is present, the reader has to check all ancestors of the class in question
          to determine if the function or destructor is virtual or not.</p>

      </div>

      <h3 id="Access_Control" style="left: -46px; position: relative;">Access Control
        <a href="https://google.github.io/styleguide/cppguide.html#Access_Control" alt="link to Access_Control">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p> Make data members
          <code>private</code>, unless they are
          <code>static const</code> (and follow the
          <a href="https://google.github.io/styleguide/cppguide.html#Constant_Names">
            naming convention for constants</a>). For technical reasons, we allow data members of a test
          fixture class to be
          <code>protected</code> when using
          <a href="https://github.com/google/googletest">Google Test
          </a>).</p>
      </div>

      <h3 id="Declaration_Order" style="left: -46px; position: relative;">Declaration Order
        <a href="https://google.github.io/styleguide/cppguide.html#Declaration_Order"
          alt="link to Declaration_Order">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Group similar declarations together, placing public parts earlier.
        </p>
      </div>

      <div class="stylebody">

        <p>A class definition should usually start with a
          <code>public:</code> section, followed by
          <code>protected:</code>, then
          <code>private:</code>. Omit sections that would be empty.</p>

        <p>Within each section, generally prefer grouping similar kinds of declarations together, and generally
          prefer the following order: types (including
          <code>typedef</code>,
          <code>using</code>, and nested structs and classes), constants, factory functions, constructors, assignment operators,
          destructor, all other methods, data members.</p>

        <p>Do not put large method definitions inline in the class definition. Usually, only trivial or
          performance-critical, and very short, methods may be defined inline. See
          <a href="https://google.github.io/styleguide/cppguide.html#Inline_Functions">Inline Functions
          </a> for more details.</p>

      </div>

      <h2 id="Functions" style="left: -46px; position: relative;">Functions
        <a href="https://google.github.io/styleguide/cppguide.html#Functions" alt="link to Functions">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h2>

      <h3 id="Function_Parameter_Ordering" style="left: -46px; position: relative;">Parameter Ordering
        <a href="https://google.github.io/styleguide/cppguide.html#Function_Parameter_Ordering"
          alt="link to Function_Parameter_Ordering">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>When defining a function, parameter order is: inputs, then outputs.
        </p>
      </div>

      <div class="stylebody">
        <p>Parameters to C/C++ functions are either input to the function, output from the function, or
          both. Input parameters are usually values or
          <code>const</code> references, while output and input/output parameters will be pointers to non-
          <code>const</code>. When ordering function parameters, put all input-only parameters before any output parameters.
          In particular, do not add new parameters to the end of the function just because they are new;
          place new input-only parameters before the output parameters.</p>

        <p>This is not a hard-and-fast rule. Parameters that are both input and output (often classes/structs)
          muddy the waters, and, as always, consistency with related functions may require you to bend
          the rule.</p>

      </div>

      <h3 id="Write_Short_Functions" style="left: -46px; position: relative;">Write Short Functions
        <a href="https://google.github.io/styleguide/cppguide.html#Write_Short_Functions"
          alt="link to Write_Short_Functions">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Prefer small and focused functions.</p>
      </div>

      <div class="stylebody">
        <p>Long functions are sometimes appropriate, so no hard limit is placed on functions
          length. If a function exceeds about 40 lines, think about whether it can be broken up without
          harming the structure of the program.</p>

        <p>Even if your long function works perfectly now, someone modifying it in a few months may add
          new behavior. This could result in bugs that are hard to find. Keeping your functions short
          and simple makes it easier for other people to read and modify your code.</p>

        <p>You could find long and complicated functions when working with some code. Do not be intimidated
          by modifying existing code: if working with such a function proves to be difficult, you find
          that errors are hard to debug, or you want to use a piece of it in several different contexts,
          consider breaking up the function into smaller and more manageable pieces.</p>

      </div>


      <h3 id="trailing_return" style="left: -46px; position: relative;">Trailing Return Type Syntax
        <a href="https://google.github.io/styleguide/cppguide.html#trailing_return"
          alt="link to trailing_return">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#trailing_return"
          alt="link to trailing_return">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>
      <div class="summary">
        <p>Use trailing return types only where using the ordinary syntax (leading return types) is impractical
          or much less readable.</p>
      </div>

      <div class="definition">
        <p>C++ allows two different forms of function declarations. In the older form, the return type appears
          before the function name. For example:</p>
        <pre>int foo(int x);
</pre>
        <p>The new form, introduced in C++11, uses the
          <code>auto</code> keyword before the function name and a trailing return type after the argument list. For example,
          the declaration above could equivalently be written:</p>
        <pre>auto foo(int x) -&gt; int;
</pre>
        <p>The trailing return type is in the function's scope. This doesn't make a difference for a simple
          case like
          <code>int</code> but it matters for more complicated cases, like types declared in class scope or types written
          in terms of the function parameters.</p>
      </div>

      <div class="stylebody">
        <div class="pros">
          <p>Trailing return types are the only way to explicitly specify the return type of a
            <a href="https://google.github.io/styleguide/cppguide.html#Lambda_expressions">lambda expression</a>. In some cases the compiler is able to deduce a lambda's return type,
            but not in all cases. Even when the compiler can deduce it automatically, sometimes specifying
            it explicitly would be clearer for readers.
          </p>
          <p>Sometimes it's easier and more readable to specify a return type after the function's parameter
            list has already appeared. This is particularly true when the return type depends on template
            parameters. For example:</p>
          <pre>template &lt;class T, class U&gt; auto add(T t, U u) -&gt; decltype(t + u);</pre> versus
          <pre>template &lt;class T, class U&gt; decltype(declval&lt;T&amp;&gt;() + declval&lt;U&amp;&gt;()) add(T t, U u);</pre>
        </div>

        <div class="cons">
          <p>Trailing return type syntax is relatively new and it has no analogue in C++-like languages
            like C and Java, so some readers may find it unfamiliar.</p>
          <p>Existing code bases have an enormous number of function declarations that aren't going to get
            changed to use the new syntax, so the realistic choices are using the old syntax only or
            using a mixture of the two. Using a single version is better for uniformity of style.</p>
        </div>

        <div class="decision">
          <p>In most cases, continue to use the older style of function declaration where the return type
            goes before the function name. Use the new trailing-return-type form only in cases where
            it's required (such as lambdas) or where, by putting the type after the function's parameter
            list, it allows you to write the type in a much more readable way. The latter case should
            be rare; it's mostly an issue in fairly complicated template code, which is
            <a href="https://google.github.io/styleguide/cppguide.html#Template_metaprogramming">discouraged in most cases</a>.</p>

        </div>
      </div>


      <h2 id="Other_C++_Features" style="left: -46px; position: relative;">Other C++ Features
        <a href="https://google.github.io/styleguide/cppguide.html#Other_C++_Features"
          alt="link to Other_C++_Features">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h2>

      <h3 id="Friends" style="left: -46px; position: relative;">Friends
        <a href="https://google.github.io/styleguide/cppguide.html#Friends" alt="link to Friends">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Friends" alt="link to Friends">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>We allow use of
          <code>friend</code> classes and functions, within reason.</p>
      </div>

      <div class="stylebody">

        <p>Friends should usually be defined in the same file so that the reader does not have to look in
          another file to find uses of the private members of a class. A common use of
          <code>friend</code> is to have a
          <code>FooBuilder</code> class be a friend of
          <code>Foo</code> so that it can construct the inner state of
          <code>Foo</code> correctly, without exposing this state to the world. In some cases it may be useful to make
          a unittest class a friend of the class it tests.</p>

        <p>Friends extend, but do not break, the encapsulation boundary of a class. In some cases this is
          better than making a member public when you want to give only one other class access to it.
          However, most classes should interact with other classes solely through their public members.
        </p>

      </div>

      
      <h3 id="Casting" style="left: -46px; position: relative;">Casting
        <a href="https://google.github.io/styleguide/cppguide.html#Casting" alt="link to Casting">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Casting" alt="link to Casting">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Use C++-style casts like
          <code>static_cast&lt;float&gt;(double_value)</code>, or brace initialization for conversion of arithmetic types like
          <code>int64 y = int64{1} &lt;&lt; 42</code>. Do not use cast formats like
          <code>int y = (int)x</code> or
          <code>int y = int(x)</code> (but the latter is okay when invoking a constructor of a class type).</p>
      </div>

      <div class="stylebody">

        <div class="definition">
          <p> C++ introduced a different cast system from C that distinguishes the types of cast operations.</p>
        </div>

        <div class="pros">
          <p>The problem with C casts is the ambiguity of the operation; sometimes you are doing a
            <em>conversion</em>
            (e.g.,
            <code>(int)3.5</code>) and sometimes you are doing a
            <em>cast</em> (e.g.,
            <code>(int)"hello"</code>). Brace initialization and C++ casts can often help avoid this ambiguity. Additionally,
            C++ casts are more visible when searching for them.
          </p>
        </div>

        <div class="cons">
          <p>The C++-style cast syntax is verbose and cumbersome.</p>
        </div>

        <div class="decision">
          <p>Do not use C-style casts. Instead, use these C++-style casts when explicit type conversion
            is necessary. </p>

          <ul>
            <li>Use brace initialization to convert arithmetic types (e.g.
              <code>int64{x}</code>). This is the safest approach because code will not compile if conversion can result in
              information loss. The syntax is also concise.</li>



            <li>Use
              <code>static_cast</code> as the equivalent of a C-style cast that does value conversion, when you need to explicitly
              up-cast a pointer from a class to its superclass, or when you need to explicitly cast a
              pointer from a superclass to a subclass. In this last case, you must be sure your object
              is actually an instance of the subclass.</li>



            <li>Use
              <code>const_cast</code> to remove the
              <code>const</code> qualifier (see
              <a href="https://google.github.io/styleguide/cppguide.html#Use_of_const">const</a>).</li>

            <li>Use
              <code>reinterpret_cast</code> to do unsafe conversions of pointer types to and from integer and other pointer types.
              Use this only if you know what you are doing and you understand the aliasing issues.
            </li>


          </ul>

          <p>See the
            <a href="https://google.github.io/styleguide/cppguide.html#Run-Time_Type_Information__RTTI_">
              RTTI section</a> for guidance on the use of
            <code>dynamic_cast</code>.</p>
        </div>

      </div>

      <h3 id="Preincrement_and_Predecrement" style="left: -46px; position: relative;">Preincrement and Predecrement
        <a href="https://google.github.io/styleguide/cppguide.html#Preincrement_and_Predecrement"
          alt="link to Preincrement_and_Predecrement">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Preincrement_and_Predecrement"
          alt="link to Preincrement_and_Predecrement">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Use prefix form (
          <code>++i</code>) of the increment and decrement operators with iterators and other template objects.
        </p>
      </div>

      <div class="stylebody">

        <div class="definition">
          <p> When a variable is incremented (
            <code>++i</code> or
            <code>i++</code>) or decremented (
            <code>--i</code> or
            <code>i--</code>) and the value of the expression is not used, one must decide whether to preincrement (decrement)
            or postincrement (decrement).
          </p>
        </div>

        <div class="pros">
          <p>When the return value is ignored, the "pre" form (
            <code>++i</code>) is never less efficient than the "post" form (
            <code>i++</code>), and is often more efficient. This is because post-increment (or decrement) requires a
            copy of
            <code>i</code> to be made, which is the value of the expression. If
            <code>i</code> is an iterator or other non-scalar type, copying
            <code>i</code> could be expensive. Since the two types of increment behave the same when the value is ignored,
            why not just always pre-increment?</p>
        </div>

        <div class="cons">
          <p>The tradition developed, in C, of using post-increment when the expression value is not used,
            especially in
            <code>for</code> loops. Some find post-increment easier to read, since the "subject" (
            <code>i</code>) precedes the "verb" (
            <code>++</code>), just like in English.</p>
        </div>

        <div class="decision">
          <p> For simple scalar (non-object) values there is no reason to prefer one form and we allow either.
            For iterators and other template types, use pre-increment.</p>
        </div>

      </div>

      <h3 id="Integer_Types" style="left: -46px; position: relative;">Integer Types
        <a href="https://google.github.io/styleguide/cppguide.html#Integer_Types" alt="link to Integer_Types">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Of the built-in C++ integer types, the only one used is
          <code>int</code>. If a program needs a variable of a different size, use a precise-width integer type from
          <code>&lt;stdint.h&gt;</code>, such as
          <code>int16_t</code>. If your variable represents a value that could ever be greater than or equal to 2^31 (2GiB),
          use a 64-bit type such as
          <code>int64_t</code>. Keep in mind that even if your value won't ever be too large for an
          <code>int</code>, it may be used in intermediate calculations which may require a larger type. When in doubt,
          choose a larger type.</p>
      </div>

      <div class="stylebody">

        <div class="definition">
          <p> C++ does not specify the sizes of its integer types. Typically people assume that
            <code>short</code> is 16 bits,
            <code>int</code> is 32 bits,
            <code>long</code> is 32 bits and
            <code>long long</code> is 64 bits.</p>
        </div>

        <div class="pros">
          <p>Uniformity of declaration.</p>
        </div>

        <div class="cons">
          <p>The sizes of integral types in C++ can vary based on compiler and architecture.</p>
        </div>

        <div class="decision">

          <p>
            <code>&lt;stdint.h&gt;</code> defines types like
            <code>int16_t</code>,
            <code>uint32_t</code>,
            <code>int64_t</code>, etc. You should always use those in preference to
            <code>short</code>,
            <code>unsigned
long long</code> and the like, when you need a guarantee on the size of an integer. Of the C integer types,
            only
            <code>int</code> should be used. When appropriate, you are welcome to use standard types like
            <code>size_t</code> and
            <code>ptrdiff_t</code>.</p>

          <p>We use
            <code>int</code> very often, for integers we know are not going to be too big, e.g., loop counters. Use plain
            old
            <code>int</code> for such things. You should assume that an
            <code>int</code> is at least 32 bits, but don't assume that it has more than 32 bits. If you need a 64-bit
            integer type, use
            <code>int64_t</code> or
            <code>uint64_t</code>.</p>

          <p>For integers we know can be "big", use
            <code>int64_t</code>.
          </p>

          <p>You should not use the unsigned integer types such as
            <code>uint32_t</code>, unless there is a valid reason such as representing a bit pattern rather than a number,
            or you need defined overflow modulo 2^N. In particular, do not use unsigned types to say
            a number will never be negative. Instead, use assertions for this.</p>



          <p>If your code is a container that returns a size, be sure to use a type that will accommodate
            any possible usage of your container. When in doubt, use a larger type rather than a smaller
            type.</p>

          <p>Use care when converting integer types. Integer conversions and promotions can cause non-intuitive
            behavior. </p>
        </div>

        <div class="stylepoint_subsection">

          <h4>On Unsigned Integers</h4>

          <p>Some people, including some textbook authors, recommend using unsigned types to represent numbers
            that are never negative. This is intended as a form of self-documentation. However, in C,
            the advantages of such documentation are outweighed by the real bugs it can introduce. Consider:</p>

          <pre>for (unsigned int i = foo.Length()-1; i &gt;= 0; --i) ...
</pre>

          <p>This code will never terminate! Sometimes gcc will notice this bug and warn you, but often
            it will not. Equally bad bugs can occur when comparing signed and unsigned variables. Basically,
            C's type-promotion scheme causes unsigned types to behave differently than one might expect.</p>

          <p>So, document that a variable is non-negative using assertions. Don't use an unsigned type.
          </p>
        </div>

      </div>

      <h2 id="Naming" style="left: -46px; position: relative;">Naming
        <a href="https://google.github.io/styleguide/cppguide.html#Naming" alt="link to Naming">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h2>

      <p>The most important consistency rules are those that govern naming. The style of a name immediately
        informs us what sort of thing the named entity is: a type, a variable, a function, a constant,
        a macro, etc., without requiring us to search for the declaration of that entity. The pattern-matching
        engine in our brains relies a great deal on these naming rules.
      </p>

      <p>Naming rules are pretty arbitrary, but we feel that consistency is more important than individual
        preferences in this area, so regardless of whether you find them sensible or not, the rules are
        the rules.</p>

      <h3 id="General_Naming_Rules" style="left: -46px; position: relative;">General Naming Rules
        <a href="https://google.github.io/styleguide/cppguide.html#General_Naming_Rules"
          alt="link to General_Naming_Rules">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Names should be descriptive; avoid abbreviation.</p>
      </div>

      <div class="stylebody">
        <p>Give as descriptive a name as possible, within reason. Do not worry about saving horizontal space
          as it is far more important to make your code immediately understandable by a new reader. Do
          not use abbreviations that are ambiguous or unfamiliar to readers outside your project, and
          do not abbreviate by deleting letters within a word.</p>

        <pre>int price_count_reader;    // No abbreviation.
int num_errors;            // "num" is a widespread convention.
int num_dns_connections;   // Most people know what "DNS" stands for.
</pre>

        <pre class="badcode">int n;                     // Meaningless.
int nerr;                  // Ambiguous abbreviation.
int n_comp_conns;          // Ambiguous abbreviation.
int wgc_connections;       // Only your group knows what this stands for.
int pc_reader;             // Lots of things can be abbreviated "pc".
int cstmr_id;              // Deletes internal letters.
</pre>

        <p>Note that certain universally-known abbreviations are OK, such as
          <code>i</code> for an iteration variable and
          <code>T</code> for a template parameter.</p>

        <p>Template parameters should follow the naming style for their category: type template parameters
          should follow the rules for
          <a href="https://google.github.io/styleguide/cppguide.html#Type_Names">type names</a>, and non-type template parameters should follow the rules for
          <a href="https://google.github.io/styleguide/cppguide.html#Variable_Names">
            variable names</a>.

        </p>
      </div>

      <h3 id="File_Names" style="left: -46px; position: relative;">File Names
        <a href="https://google.github.io/styleguide/cppguide.html#File_Names" alt="link to File_Names">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Filenames should be all lowercase and can include underscores (
          <code>_</code>) or dashes (
          <code>-</code>). Follow the convention that your project uses. If there is no consistent local pattern to
          follow, prefer "_".</p>
      </div>

      <div class="stylebody">

        <p>Examples of acceptable file names:</p>

        <ul>
          <li>
            <code>my_useful_class.cc</code>
          </li>
          <li>
            <code>my-useful-class.cc</code>
          </li>
          <li>
            <code>myusefulclass.cc</code>
          </li>
          <li>
            <code>myusefulclass_test.cc // _unittest and _regtest are deprecated.</code>
          </li>
        </ul>

        <p>C++ files should end in
          <code>.cc</code> and header files should end in
          <code>.h</code>. Files that rely on being textually included at specific points should end in
          <code>.inc</code> (see also the section on
          <a href="https://google.github.io/styleguide/cppguide.html#Self_contained_Headers">self-contained headers</a>).</p>

        <p>Do not use filenames that already exist in
          <code>/usr/include</code>, such as
          <code>db.h</code>.</p>

        <p>In general, make your filenames very specific. For example, use
          <code>http_server_logs.h</code> rather than
          <code>logs.h</code>. A very common case is to have a pair of files called, e.g.,
          <code>foo_bar.h</code> and
          <code>foo_bar.cc</code>, defining a class called
          <code>FooBar</code>.</p>

        <p>Inline functions must be in a
          <code>.h</code> file. If your inline functions are very short, they should go directly into your
          <code>.h</code> file. </p>

      </div>

      <h3 id="Type_Names" style="left: -46px; position: relative;">Type Names
        <a href="https://google.github.io/styleguide/cppguide.html#Type_Names" alt="link to Type_Names">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Type names start with a capital letter and have a capital letter for each new word, with no underscores:
          <code>MyExcitingClass</code>,
          <code>MyExcitingEnum</code>.</p>
      </div>

      <div class="stylebody">

        <p>The names of all types — classes, structs, type aliases, enums, and type template parameters
          — have the same naming convention. Type names should start with a capital letter and have a
          capital letter for each new word. No underscores. For example:</p>

        <pre>// classes and structs
class UrlTable { ...
class UrlTableTester { ...
struct UrlTableProperties { ...

// typedefs
typedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;

// using aliases
using PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;;

// enums
enum UrlTableErrors { ...
</pre>

      </div>

      <h3 id="Variable_Names" style="left: -46px; position: relative;">Variable Names
        <a href="https://google.github.io/styleguide/cppguide.html#Variable_Names" alt="link to Variable_Names">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>The names of variables (including function parameters) and data members are all lowercase, with
          underscores between words. Data members of classes (but not structs) additionally have trailing
          underscores. For instance:
          <code>a_local_variable</code>,
          <code>a_struct_data_member</code>,
          <code>a_class_data_member_</code>.</p>
      </div>

      <div class="stylebody">

        <h4 class="stylepoint_subsection">Common Variable names</h4>

        <p>For example:</p>

        <pre>string table_name;  // OK - uses underscore.
string tablename;   // OK - all lowercase.
</pre>

        <pre class="badcode">string tableName;   // Bad - mixed case.
</pre>

        <h4 class="stylepoint_subsection">Class Data Members</h4>

        <p>Data members of classes, both static and non-static, are named like ordinary nonmember variables,
          but with a trailing underscore.</p>

        <pre>class TableInfo {
  ...
 private:
  string table_name_;  // OK - underscore at end.
  string tablename_;   // OK.
  static Pool&lt;TableInfo&gt;* pool_;  // OK.
};
</pre>

        <h4 class="stylepoint_subsection">Struct Data Members</h4>

        <p>Data members of structs, both static and non-static, are named like ordinary nonmember variables.
          They do not have the trailing underscores that data members in classes have.</p>

        <pre>struct UrlTableProperties {
  string name;
  int num_entries;
  static Pool&lt;UrlTableProperties&gt;* pool;
};
</pre>


        <p>See
          <a href="https://google.github.io/styleguide/cppguide.html#Structs_vs._Classes">Structs vs. Classes
          </a> for a discussion of when to use a struct versus a class.</p>

      </div>

      <h3 id="Constant_Names" style="left: -46px; position: relative;">Constant Names
        <a href="https://google.github.io/styleguide/cppguide.html#Constant_Names" alt="link to Constant_Names">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Variables declared constexpr or const, and whose value is fixed for the duration of the program,
          are named with a leading "k" followed by mixed case. For example:</p>
      </div>

      <pre>const int kDaysInAWeek = 7;
</pre>

      <div class="stylebody">

        <p>All such variables with static storage duration (i.e. statics and globals, see
          <a href="http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration">
            Storage Duration</a> for details) should be named this way. This convention is optional for
          variables of other storage classes, e.g. automatic variables, otherwise the usual variable
          naming rules apply.</p>
        <p>

        </p>
      </div>

      <h3 id="Function_Names" style="left: -46px; position: relative;">Function Names
        <a href="https://google.github.io/styleguide/cppguide.html#Function_Names" alt="link to Function_Names">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Regular functions have mixed case; accessors and mutators may be named like variables.</p>
      </div>

      <div class="stylebody">

        <p>Ordinarily, functions should start with a capital letter and have a capital letter for each new
          word (a.k.a. "
          <a href="https://en.wikipedia.org/wiki/Camel_case">Camel Case
          </a>" or "Pascal case"). Such names should not have underscores. Prefer to capitalize acronyms
          as single words (i.e.
          <code>StartRpc()</code>, not
          <code>StartRPC()</code>).</p>

        <pre>AddTableEntry()
DeleteUrl()
OpenFileOrDie()
</pre>

        <p>(The same naming rule applies to class- and namespace-scope constants that are exposed as part
          of an API and that are intended to look like functions, because the fact that they're objects
          rather than functions is an unimportant implementation detail.)</p>

        <p>Accessors and mutators (get and set functions) may be named like variables. These often correspond
          to actual member variables, but this is not required. For example,
          <code>int count()</code> and
          <code>void
set_count(int count)</code>.</p>

      </div>

      <h3 id="Namespace_Names" style="left: -46px; position: relative;">Namespace Names
        <a href="https://google.github.io/styleguide/cppguide.html#Namespace_Names" alt="link to Namespace_Names">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        Namespace names are all lower-case. Top-level namespace names are based on the project name . Avoid collisions
        between nested namespaces and well-known top-level namespaces.
      </div>

      <div class="stylebody">
        <p>The name of a top-level namespace should usually be the name of the project or team whose code
          is contained in that namespace. The code in that namespace should usually be in a directory
          whose basename matches the namespace name (or subdirectories thereof).</p>





        <p>Keep in mind that the
          <a href="https://google.github.io/styleguide/cppguide.html#General_Naming_Rules">rule against abbreviated names</a> applies to namespaces just as much as variable names. Code
          inside the namespace seldom needs to mention the namespace name, so there's usually no particular
          need for abbreviation anyway.</p>

        <p>Avoid nested namespaces that match well-known top-level namespaces. Collisions between namespace
          names can lead to surprising build breaks because of name lookup rules. In particular, do not
          create any nested
          <code>std</code> namespaces. Prefer unique project identifiers (
          <code>websearch::index</code>,
          <code>websearch::index_util</code>) over collision-prone names like
          <code>websearch::util</code>.</p>

        <p>For
          <code>internal</code> namespaces, be wary of other code being added to the same
          <code>internal</code> namespace causing a collision (internal helpers within a team tend to be related and may lead
          to collisions). In such a situation, using the filename to make a unique internal name is helpful
          (
          <code>websearch::index::frobber_internal</code> for use in
          <code>frobber.h</code>)</p>

      </div>

      <h3 id="Enumerator_Names" style="left: -46px; position: relative;">Enumerator Names
        <a href="https://google.github.io/styleguide/cppguide.html#Enumerator_Names" alt="link to Enumerator_Names">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Enumerators (for both scoped and unscoped enums) should be named
          <i>either</i> like
          <a href="https://google.github.io/styleguide/cppguide.html#Constant_Names">constants</a> or like
          <a href="https://google.github.io/styleguide/cppguide.html#Macro_Names">macros</a>: either
          <code>kEnumName</code> or
          <code>ENUM_NAME</code>.</p>
      </div>

      <div class="stylebody">

        <p>Preferably, the individual enumerators should be named like
          <a href="https://google.github.io/styleguide/cppguide.html#Constant_Names">constants</a>. However, it is also acceptable to name them like
          <a href="https://google.github.io/styleguide/cppguide.html#Macro_Names">macros</a>. The enumeration name,
          <code>UrlTableErrors</code> (and
          <code>AlternateUrlTableErrors</code>), is a type, and therefore mixed case.</p>

        <pre>enum UrlTableErrors {
  kOK = 0,
  kErrorOutOfMemory,
  kErrorMalformedInput,
};
enum AlternateUrlTableErrors {
  OK = 0,
  OUT_OF_MEMORY = 1,
  MALFORMED_INPUT = 2,
};
</pre>

        <p>Until January 2009, the style was to name enum values like
          <a href="https://google.github.io/styleguide/cppguide.html#Macro_Names">macros</a>. This caused problems with name collisions between enum values and macros. Hence,
          the change to prefer constant-style naming was put in place. New code should prefer constant-style
          naming if possible. However, there is no reason to change old code to use constant-style names,
          unless the old names are actually causing a compile-time problem.</p>



      </div>

      <h3 id="Macro_Names" style="left: -46px; position: relative;">Macro Names
        <a href="https://google.github.io/styleguide/cppguide.html#Macro_Names" alt="link to Macro_Names">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>You're not really going to
          <a href="https://google.github.io/styleguide/cppguide.html#Preprocessor_Macros">
            define a macro</a>, are you? If you do, they're like this:
          <code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN</code>.</p>
      </div>

      <div class="stylebody">

        <p>Please see the
          <a href="https://google.github.io/styleguide/cppguide.html#Preprocessor_Macros">description of macros</a>; in general macros should
          <em>not</em> be used. However, if they are absolutely needed, then they should be named with all
          capitals and underscores.</p>

        <pre>#define ROUND(x) ...
#define PI_ROUNDED 3.0
</pre>

      </div>

      <h3 id="Exceptions_to_Naming_Rules" style="left: -46px; position: relative;">Exceptions to Naming Rules
        <a href="https://google.github.io/styleguide/cppguide.html#Exceptions_to_Naming_Rules"
          alt="link to Exceptions_to_Naming_Rules">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>If you are naming something that is analogous to an existing C or C++ entity then you can follow
          the existing naming convention scheme.</p>
      </div>

      <div class="stylebody">

        <dl>
          <dt>
            <code>bigopen()</code>
          </dt>
          <dd>function name, follows form of
            <code>open()</code>
          </dd>

          <dt>
            <code>uint</code>
          </dt>
          <dd>
            <code>typedef</code>
          </dd>

          <dt>
            <code>bigpos</code>
          </dt>
          <dd>
            <code>struct</code> or
            <code>class</code>, follows form of
            <code>pos</code>
          </dd>

          <dt>
            <code>sparse_hash_map</code>
          </dt>
          <dd>STL-like entity; follows STL naming conventions</dd>

          <dt>
            <code>LONGLONG_MAX</code>
          </dt>
          <dd>a constant, as in
            <code>INT_MAX</code>
          </dd>
        </dl>

      </div>

      <h2 id="Comments" style="left: -46px; position: relative;">Comments
        <a href="https://google.github.io/styleguide/cppguide.html#Comments" alt="link to Comments">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h2>

      <p>Though a pain to write, comments are absolutely vital to keeping our code readable. The following
        rules describe what you should comment and where. But remember: while comments are very important,
        the best code is self-documenting. Giving sensible names to types and variables is much better
        than using obscure names that you must then explain through comments.</p>

      <p>When writing your comments, write for your audience: the next contributor who will need to understand
        your code. Be generous — the next one may be you!</p>

      <h3 id="Comment_Style" style="left: -46px; position: relative;">Comment Style
        <a href="https://google.github.io/styleguide/cppguide.html#Comment_Style" alt="link to Comment_Style">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Use either the
          <code>//</code> or
          <code>/* */</code> syntax, as long as you are consistent.</p>
      </div>

      <div class="stylebody">

        <p>You can use either the
          <code>//</code> or the
          <code>/*
*/</code> syntax; however,
          <code>//</code> is
          <em>much</em> more common. Be consistent with how you comment and what style you use where.</p>

      </div>

      <h3 id="File_Comments" style="left: -46px; position: relative;">File Comments
        <a href="https://google.github.io/styleguide/cppguide.html#File_Comments" alt="link to File_Comments">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Start each file with license boilerplate.</p>

        <p>File comments describe the contents of a file. If a file declares, implements, or tests exactly
          one abstraction that is documented by a comment at the point of declaration, file comments
          are not required. All other files must have file comments.</p>

      </div>

      <div class="stylebody">

        <h4 class="stylepoint_subsection">Legal Notice and Author Line
        </h4>



        <p>Every file should contain license boilerplate. Choose the appropriate boilerplate for the license
          used by the project (for example, Apache 2.0, BSD, LGPL, GPL).</p>

        <p>If you make significant changes to a file with an author line, consider deleting the author line.</p>

        <h4 class="stylepoint_subsection">File Contents</h4>

        <p>If a
          <code>.h</code> declares multiple abstractions, the file-level comment should broadly describe the contents
          of the file, and how the abstractions are related. A 1 or 2 sentence file-level comment may
          be sufficient. The detailed documentation about individual abstractions belongs with those
          abstractions, not at the file level.</p>

        <p>Do not duplicate comments in both the
          <code>.h</code> and the
          <code>.cc</code>. Duplicated comments diverge.</p>

      </div>

      <h3 id="Class_Comments" style="left: -46px; position: relative;">Class Comments
        <a href="https://google.github.io/styleguide/cppguide.html#Class_Comments" alt="link to Class_Comments">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Every non-obvious class declaration should have an accompanying comment that describes what it
          is for and how it should be used.</p>
      </div>

      <div class="stylebody">

        <pre>// Iterates over the contents of a GargantuanTable.
// Example:
//    GargantuanTableIterator* iter = table-&gt;NewIterator();
//    for (iter-&gt;Seek("foo"); !iter-&gt;done(); iter-&gt;Next()) {
//      process(iter-&gt;key(), iter-&gt;value());
//    }
//    delete iter;
class GargantuanTableIterator {
  ...
};
</pre>

        <p>The class comment should provide the reader with enough information to know how and when to use
          the class, as well as any additional considerations necessary to correctly use the class. Document
          the synchronization assumptions the class makes, if any. If an instance of the class can be
          accessed by multiple threads, take extra care to document the rules and invariants surrounding
          multithreaded use.</p>

        <p>The class comment is often a good place for a small example code snippet demonstrating a simple
          and focused usage of the class.</p>

        <p>When sufficiently separated (e.g.
          <code>.h</code> and
          <code>.cc</code> files), comments describing the use of the class should go together with its interface definition;
          comments about the class operation and implementation should accompany the implementation of
          the class's methods.</p>

      </div>

      <h3 id="Function_Comments" style="left: -46px; position: relative;">Function Comments
        <a href="https://google.github.io/styleguide/cppguide.html#Function_Comments"
          alt="link to Function_Comments">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Declaration comments describe use of the function (when it is non-obvious); comments at the definition
          of a function describe operation.
        </p>
      </div>

      <div class="stylebody">

        <h4 class="stylepoint_subsection">Function Declarations</h4>

        <p>Almost every function declaration should have comments immediately preceding it that describe
          what the function does and how to use it. These comments may be omitted only if the function
          is simple and obvious (e.g. simple accessors for obvious properties of the class). These comments
          should be descriptive ("Opens the file") rather than imperative ("Open the file"); the comment
          describes the function, it does not tell the function what to do. In general, these comments
          do not describe how the function performs its task. Instead, that should be left to comments
          in the function definition.</p>

        <p>Types of things to mention in comments at the function declaration:
        </p>

        <ul>
          <li>What the inputs and outputs are.</li>

          <li>For class member functions: whether the object remembers reference arguments beyond the duration
            of the method call, and whether it will free them or not.
          </li>

          <li>If the function allocates memory that the caller must free.</li>

          <li>Whether any of the arguments can be a null pointer.
          </li>

          <li>If there are any performance implications of how a function is used.</li>

          <li>If the function is re-entrant. What are its synchronization assumptions?</li>
        </ul>

        <p>Here is an example:</p>

        <pre>// Returns an iterator for this table.  It is the client's
// responsibility to delete the iterator when it is done with it,
// and it must not use the iterator once the GargantuanTable object
// on which the iterator was created has been deleted.
//
// The iterator is initially positioned at the beginning of the table.
//
// This method is equivalent to:
//    Iterator* iter = table-&gt;NewIterator();
//    iter-&gt;Seek("");
//    return iter;
// If you are going to immediately seek to another place in the
// returned iterator, it will be faster to use NewIterator()
// and avoid the extra seek.
Iterator* GetIterator() const;
</pre>

        <p>However, do not be unnecessarily verbose or state the completely obvious. Notice below that it
          is not necessary to say "returns false otherwise" because this is implied.
        </p>

        <pre>// Returns true if the table cannot hold any more entries.
bool IsTableFull();
</pre>

        <p>When documenting function overrides, focus on the specifics of the override itself, rather than
          repeating the comment from the overridden function. In many of these cases, the override needs
          no additional documentation and thus no comment is required.</p>

        <p>When commenting constructors and destructors, remember that the person reading your code knows
          what constructors and destructors are for, so comments that just say something like "destroys
          this object" are not useful. Document what constructors do with their arguments (for example,
          if they take ownership of pointers), and what cleanup the destructor does. If this is trivial,
          just skip the comment. It is quite common for destructors not to have a header comment.</p>

        <h4 class="stylepoint_subsection">Function Definitions</h4>

        <p>If there is anything tricky about how a function does its job, the function definition should
          have an explanatory comment. For example, in the definition comment you might describe any
          coding tricks you use, give an overview of the steps you go through, or explain why you chose
          to implement the function in the way you did rather than using a viable alternative. For instance,
          you might mention why it must acquire a lock for the first half of the function but why it
          is not needed for the second half.</p>

        <p>Note you should
          <em>not</em> just repeat the comments given with the function declaration, in the
          <code>.h</code> file or wherever. It's okay to recapitulate briefly what the function does, but the focus
          of the comments should be on how it does it.</p>

      </div>

      <h3 id="Variable_Comments" style="left: -46px; position: relative;">Variable Comments
        <a href="https://google.github.io/styleguide/cppguide.html#Variable_Comments"
          alt="link to Variable_Comments">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>In general the actual name of the variable should be descriptive enough to give a good idea of
          what the variable is used for. In certain cases, more comments are required.</p>
      </div>

      <div class="stylebody">

        <h4 class="stylepoint_subsection">Class Data Members</h4>

        <p>The purpose of each class data member (also called an instance variable or member variable) must
          be clear. If there are any invariants (special values, relationships between members, lifetime
          requirements) not clearly expressed by the type and name, they must be commented. However,
          if the type and name suffice (
          <code>int
num_events_;</code>), no comment is needed.</p>

        <p>In particular, add comments to describe the existence and meaning of sentinel values, such as
          nullptr or -1, when they are not obvious. For example:</p>

        <pre>private:
 // Used to bounds-check table accesses. -1 means
 // that we don't yet know how many entries the table has.
 int num_total_entries_;
</pre>

        <h4 class="stylepoint_subsection">Global Variables</h4>

        <p>All global variables should have a comment describing what they are, what they are used for,
          and (if unclear) why it needs to be global. For example:</p>

        <pre>// The total number of tests cases that we run through in this regression test.
const int kNumTestCases = 6;
</pre>

      </div>

      <h3 id="Implementation_Comments" style="left: -46px; position: relative;">Implementation Comments
        <a href="https://google.github.io/styleguide/cppguide.html#Implementation_Comments"
          alt="link to Implementation_Comments">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>In your implementation you should have comments in tricky, non-obvious, interesting, or important
          parts of your code.</p>
      </div>

      <div class="stylebody">

        <h4 class="stylepoint_subsection">Explanatory Comments</h4>

        <p>Tricky or complicated code blocks should have comments before them. Example:</p>

        <pre>// Divide result by two, taking into account that x
// contains the carry from the add.
for (int i = 0; i &lt; result-&gt;size(); i++) {
  x = (x &lt;&lt; 8) + (*result)[i];
  (*result)[i] = x &gt;&gt; 1;
  x &amp;= 1;
}
</pre>

        <h4 class="stylepoint_subsection">Line Comments</h4>

        <p>Also, lines that are non-obvious should get a comment at the end of the line. These end-of-line
          comments should be separated from the code by 2 spaces. Example:</p>

        <pre>// If we have enough memory, mmap the data portion too.
mmap_budget = max&lt;int64&gt;(0, mmap_budget - index_-&gt;length());
if (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))
  return;  // Error already logged.
</pre>

        <p>Note that there are both comments that describe what the code is doing, and comments that mention
          that an error has already been logged when the function returns.
        </p>

        <p>If you have several comments on subsequent lines, it can often be more readable to line them
          up:</p>

        <pre>DoSomething();                  // Comment here so the comments line up.
DoSomethingElseThatIsLonger();  // Two spaces between the code and the comment.
{ // One space before comment when opening a new scope is allowed,
  // thus the comment lines up with the following comments and code.
  DoSomethingElse();  // Two spaces before line comments normally.
}
std::vector&lt;string&gt; list{
                    // Comments in braced lists describe the next element...
                    "First item",
                    // .. and should be aligned appropriately.
                    "Second item"};
DoSomething(); /* For trailing block comments, one space is fine. */
</pre>

        <h4 class="stylepoint_subsection">Function Argument Comments</h4>

        <p>When the meaning of a function argument is nonobvious, consider one of the following remedies:</p>

        <ul>
          <li>If the argument is a literal constant, and the same constant is used in multiple function calls
            in a way that tacitly assumes they're the same, you should use a named constant to make that
            constraint explicit, and to guarantee that it holds.</li>

          <li>Consider changing the function signature to replace a
            <code>bool</code> argument with an
            <code>enum</code> argument. This will make the argument values self-describing.</li>

          <li>For functions that have several configuration options, consider defining a single class or
            struct to hold all the options , and pass an instance of that. This approach has several
            advantages. Options are referenced by name at the call site, which clarifies their meaning.
            It also reduces function argument count, which makes function calls easier to read and write.
            As an added benefit, you don't have to change call sites when you add another option.
          </li>

          <li>Replace large or complex nested expressions with named variables.</li>

          <li>As a last resort, use comments to clarify argument meanings at the call site.</li>
        </ul>

        Consider the following example:

        <pre class="badcode">// What are these arguments?
const DecimalNumber product = CalculateProduct(values, 7, false, nullptr);
</pre>

        <p>versus:</p>

        <pre>ProductOptions options;
options.set_precision_decimals(7);
options.set_use_cache(ProductOptions::kDontUseCache);
const DecimalNumber product =
    CalculateProduct(values, options, /*completion_callback=*/nullptr);
</pre>

        <h4 class="stylepoint_subsection">Don'ts</h4>

        <p>Do not state the obvious. In particular, don't literally describe what code does, unless the
          behavior is nonobvious to a reader who understands C++ well. Instead, provide higher level
          comments that describe
          <i>why</i>
          the code does what it does, or make the code self describing.</p>

        Compare this:

        <pre class="badcode">// Find the element in the vector.  &lt;-- Bad: obvious!
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) {
  Process(element);
}
</pre> To this:

        <pre>// Process "element" unless it was already processed.
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) {
  Process(element);
}
</pre> Self-describing code doesn't need a comment. The comment from the example above would be obvious:

        <pre>if (!IsAlreadyProcessed(element)) {
  Process(element);
}
</pre>

      </div>

      <h3 id="Punctuation,_Spelling_and_Grammar" style="left: -46px; position: relative;">Punctuation, Spelling and Grammar
        <a href="https://google.github.io/styleguide/cppguide.html#Punctuation,_Spelling_and_Grammar"
          alt="link to Punctuation,_Spelling_and_Grammar">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Pay attention to punctuation, spelling, and grammar; it is easier to read well-written comments
          than badly written ones.
        </p>
      </div>

      <div class="stylebody">

        <p>Comments should be as readable as narrative text, with proper capitalization and punctuation.
          In many cases, complete sentences are more readable than sentence fragments. Shorter comments,
          such as comments at the end of a line of code, can sometimes be less formal, but you should
          be consistent with your style.</p>

        <p>Although it can be frustrating to have a code reviewer point out that you are using a comma when
          you should be using a semicolon, it is very important that source code maintain a high level
          of clarity and readability. Proper punctuation, spelling, and grammar help with that goal.
        </p>

      </div>

      <h3 id="TODO_Comments" style="left: -46px; position: relative;">TODO Comments
        <a href="https://google.github.io/styleguide/cppguide.html#TODO_Comments" alt="link to TODO_Comments">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Use
          <code>TODO</code> comments for code that is temporary, a short-term solution, or good-enough but not perfect.</p>
      </div>

      <div class="stylebody">

        <p>
          <code>TODO</code>s should include the string
          <code>TODO</code> in all caps, followed by the name, e-mail address, bug ID, or other identifier of the person
          or issue with the best context about the problem referenced by the
          <code>TODO</code>. The main purpose is to have a consistent
          <code>TODO</code> that can be searched to find out how to get more details upon request. A
          <code>TODO</code> is not a commitment that the person referenced will fix the problem. Thus when you create
          a
          <code>TODO</code> with a name, it is almost always your name that is given.</p>



        <div>
          <pre>// TODO(kl@gmail.com): Use a "*" here for concatenation operator.
// TODO(Zeke) change this to use relations.
// TODO(bug 12345): remove the "Last visitors" feature
</pre>
        </div>

        <p>If your
          <code>TODO</code> is of the form "At a future date do something" make sure that you either include a very specific
          date ("Fix by November 2005") or a very specific event ("Remove this code when all clients
          can handle XML responses.").</p>

      </div>

      <h3 id="Deprecation_Comments" style="left: -46px; position: relative;">Deprecation Comments
        <a href="https://google.github.io/styleguide/cppguide.html#Deprecation_Comments"
          alt="link to Deprecation_Comments">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Mark deprecated interface points with
          <code>DEPRECATED</code> comments.
        </p>
      </div>

      <div class="stylebody">

        <p>You can mark an interface as deprecated by writing a comment containing the word
          <code>DEPRECATED</code> in all caps. The comment goes either before the declaration of the interface or on the same
          line as the declaration.
        </p>



        <p>After the word
          <code>DEPRECATED</code>, write your name, e-mail address, or other identifier in parentheses.</p>

        <p>A deprecation comment must include simple, clear directions for people to fix their callsites.
          In C++, you can implement a deprecated function as an inline function that calls the new interface
          point.</p>

        <p>Marking an interface point
          <code>DEPRECATED</code> will not magically cause any callsites to change. If you want people to actually stop using
          the deprecated facility, you will have to fix the callsites yourself or recruit a crew to help
          you.</p>

        <p>New code should not contain calls to deprecated interface points. Use the new interface point
          instead. If you cannot understand the directions, find the person who created the deprecation
          and ask them for help using the new interface point.</p>



      </div>

      <h2 id="Formatting" style="left: -46px; position: relative;">Formatting
        <a href="https://google.github.io/styleguide/cppguide.html#Formatting" alt="link to Formatting">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Formatting"
          alt="link to Formatting">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h2>

      <p>Coding style and formatting are pretty arbitrary, but a project is much easier to follow if everyone
        uses the same style. Individuals may not agree with every aspect of the formatting rules, and
        some of the rules may take some getting used to, but it is important that all project contributors
        follow the style rules so that they can all read and understand everyone's code easily.</p>



      <p>To help you format code correctly, we've created a
        <a href="https://raw.githubusercontent.com/google/styleguide/gh-pages/google-c-style.el">
          settings file for emacs</a>.</p>

      <h3 id="Line_Length" style="left: -46px; position: relative;">Line Length
        <a href="https://google.github.io/styleguide/cppguide.html#Line_Length" alt="link to Line_Length">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Line_Length"
          alt="link to Line_Length">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Each line of text in your code should be at most 80 characters long.</p>
      </div>

      <div class="stylebody">



        <p>We recognize that this rule is controversial, but so much existing code already adheres to it,
          and we feel that consistency is important.</p>

        <div class="pros">
          <p>Those who favor this rule argue that it is rude to force them to resize their windows and there
            is no need for anything longer. Some folks are used to having several code windows side-by-side,
            and thus don't have room to widen their windows in any case. People set up their work environment
            assuming a particular maximum window width, and 80 columns has been the traditional standard.
            Why change it?
          </p>
        </div>

        <div class="cons">
          <p>Proponents of change argue that a wider line can make code more readable. The 80-column limit
            is an hidebound throwback to 1960s mainframes; modern equipment has wide screens that can
            easily show longer lines.</p>
        </div>

        <div class="decision">
          <p> 80 characters is the maximum.</p>

          <p class="exception">Comment lines can be longer than 80 characters if it is not feasible to split them without
            harming readability, ease of cut and paste or auto-linking -- e.g. if a line contains an
            example command or a literal URL longer than 80 characters.</p>

          <p class="exception">A raw-string literal may have content that exceeds 80 characters. Except for test code, such
            literals should appear near the top of a file.</p>

          <p class="exception">An
            <code>#include</code> statement with a long path may exceed 80 columns.</p>

          <p class="exception">You needn't be concerned about
            <a href="https://google.github.io/styleguide/cppguide.html#The__define_Guard">header guards</a> that exceed the maximum length. </p>
        </div>

      </div>

      <h3 id="Non-ASCII_Characters" style="left: -46px; position: relative;">Non-ASCII Characters
        <a href="https://google.github.io/styleguide/cppguide.html#Non-ASCII_Characters"
          alt="link to Non-ASCII_Characters">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Non-ASCII_Characters"
          alt="link to Non-ASCII_Characters">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Non-ASCII characters should be rare, and must use UTF-8 formatting.
        </p>
      </div>

      <div class="stylebody">

        <p>You shouldn't hard-code user-facing text in source, even English, so use of non-ASCII characters
          should be rare. However, in certain cases it is appropriate to include such words in your code.
          For example, if your code parses data files from foreign sources, it may be appropriate to
          hard-code the non-ASCII string(s) used in those data files as delimiters. More commonly, unittest
          code (which does not need to be localized) might contain non-ASCII strings. In such cases,
          you should use UTF-8, since that is an encoding understood by most tools able to handle more
          than just ASCII.
        </p>

        <p>Hex encoding is also OK, and encouraged where it enhances readability — for example,
          <code>"\xEF\xBB\xBF"</code>, or, even more simply,
          <code>u8"\uFEFF"</code>, is the Unicode zero-width no-break space character, which would be invisible if included
          in the source as straight UTF-8.</p>

        <p>Use the
          <code>u8</code> prefix to guarantee that a string literal containing
          <code>\uXXXX</code> escape sequences is encoded as UTF-8. Do not use it for strings containing non-ASCII characters
          encoded as UTF-8, because that will produce incorrect output if the compiler does not interpret
          the source file as UTF-8. </p>

        <p>You shouldn't use the C++11
          <code>char16_t</code> and
          <code>char32_t</code> character types, since they're for non-UTF-8 text. For similar reasons you also shouldn't
          use
          <code>wchar_t</code> (unless you're writing code that interacts with the Windows API, which uses
          <code>wchar_t</code> extensively).</p>

      </div>

      <h3 id="Spaces_vs._Tabs" style="left: -46px; position: relative;">Spaces vs. Tabs
        <a href="https://google.github.io/styleguide/cppguide.html#Spaces_vs._Tabs" alt="link to Spaces_vs._Tabs">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Spaces_vs._Tabs"
          alt="link to Spaces_vs._Tabs">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Use only spaces, and indent 2 spaces at a time.</p>
      </div>

      <div class="stylebody">

        <p>We use spaces for indentation. Do not use tabs in your code. You should set your editor to emit
          spaces when you hit the tab key.</p>

      </div>

      <h3 id="Function_Declarations_and_Definitions" style="left: -46px; position: relative;">Function Declarations and Definitions
        <a href="https://google.github.io/styleguide/cppguide.html#Function_Declarations_and_Definitions"
          alt="link to Function_Declarations_and_Definitions">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Function_Declarations_and_Definitions"
          alt="link to Function_Declarations_and_Definitions">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Return type on the same line as function name, parameters on the same line if they fit. Wrap
          parameter lists which do not fit on a single line as you would wrap arguments in a
          <a href="https://google.github.io/styleguide/cppguide.html#Function_Calls">function call</a>.</p>
      </div>

      <div class="stylebody">

        <p>Functions look like this:</p>


        <pre>ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {
  DoSomething();
  ...
}
</pre>

        <p>If you have too much text to fit on one line:</p>

        <pre>ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,
                                             Type par_name3) {
  DoSomething();
  ...
}
</pre>

        <p>or if you cannot fit even the first parameter:</p>

        <pre>ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
    Type par_name1,  // 4 space indent
    Type par_name2,
    Type par_name3) {
  DoSomething();  // 2 space indent
  ...
}
</pre>

        <p>Some points to note:</p>

        <ul>
          <li>Choose good parameter names.</li>

          <li>Parameter names may be omitted only if the parameter is unused and its purpose is obvious.</li>

          <li>If you cannot fit the return type and the function name on a single line, break between them.</li>

          <li>If you break after the return type of a function declaration or definition, do not indent.</li>

          <li>The open parenthesis is always on the same line as the function name.</li>

          <li>There is never a space between the function name and the open parenthesis.</li>

          <li>There is never a space between the parentheses and the parameters.</li>

          <li>The open curly brace is always on the end of the last line of the function declaration, not
            the start of the next line.</li>

          <li>The close curly brace is either on the last line by itself or on the same line as the open
            curly brace.</li>

          <li>There should be a space between the close parenthesis and the open curly brace.</li>

          <li>All parameters should be aligned if possible.</li>

          <li>Default indentation is 2 spaces.</li>

          <li>Wrapped parameters have a 4 space indent.</li>
        </ul>

        <p>Unused parameters that are obvious from context may be omitted:</p>

        <pre>class Foo {
 public:
  Foo(Foo&amp;&amp;);
  Foo(const Foo&amp;);
  Foo&amp; operator=(Foo&amp;&amp;);
  Foo&amp; operator=(const Foo&amp;);
};
</pre>

        <p>Unused parameters that might not be obvious should comment out the variable name in the function
          definition:</p>

        <pre>class Shape {
 public:
  virtual void Rotate(double radians) = 0;
};

class Circle : public Shape {
 public:
  void Rotate(double radians) override;
};

void Circle::Rotate(double /*radians*/) {}
</pre>

        <pre class="badcode">// Bad - if someone wants to implement later, it's not clear what the
// variable means.
void Circle::Rotate(double) {}
</pre>

        <p>Attributes, and macros that expand to attributes, appear at the very beginning of the function
          declaration or definition, before the return type:</p>
        <pre>MUST_USE_RESULT bool IsOK();
</pre>

      </div>

      <h3 id="Formatting_Lambda_Expressions" style="left: -46px; position: relative;">Lambda Expressions
        <a href="https://google.github.io/styleguide/cppguide.html#Formatting_Lambda_Expressions"
          alt="link to Formatting_Lambda_Expressions">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Formatting_Lambda_Expressions"
          alt="link to Formatting_Lambda_Expressions">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Format parameters and bodies as for any other function, and capture lists like other comma-separated
          lists.</p>
      </div>

      <div class="stylebody">
        <p>For by-reference captures, do not leave a space between the ampersand (&amp;) and the variable
          name.</p>
        <pre>int x = 0;
auto x_plus_n = [&amp;x](int n) -&gt; int { return x + n; }
</pre>
        <p>Short lambdas may be written inline as function arguments.</p>
        <pre>std::set&lt;int&gt; blacklist = {7, 8, 9};
std::vector&lt;int&gt; digits = {3, 9, 1, 8, 4, 7, 1};
digits.erase(std::remove_if(digits.begin(), digits.end(), [&amp;blacklist](int i) {
               return blacklist.find(i) != blacklist.end();
             }),
             digits.end());
</pre>

      </div>

      <h3 id="Function_Calls" style="left: -46px; position: relative;">Function Calls
        <a href="https://google.github.io/styleguide/cppguide.html#Function_Calls" alt="link to Function_Calls">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Function_Calls"
          alt="link to Function_Calls">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Either write the call all on a single line, wrap the arguments at the parenthesis, or start the
          arguments on a new line indented by four spaces and continue at that 4 space indent. In the
          absence of other considerations, use the minimum number of lines, including placing multiple
          arguments on each line where appropriate.</p>
      </div>

      <div class="stylebody">

        <p>Function calls have the following format:</p>
        <pre>bool result = DoSomething(argument1, argument2, argument3);
</pre>

        <p>If the arguments do not all fit on one line, they should be broken up onto multiple lines, with
          each subsequent line aligned with the first argument. Do not add spaces after the open paren
          or before the close paren:
        </p>
        <pre>bool result = DoSomething(averyveryveryverylongargument1,
                          argument2, argument3);
</pre>

        <p>Arguments may optionally all be placed on subsequent lines with a four space indent:</p>
        <pre>if (...) {
  ...
  ...
  if (...) {
    bool result = DoSomething(
        argument1, argument2,  // 4 space indent
        argument3, argument4);
    ...
  }
</pre>

        <p>Put multiple arguments on a single line to reduce the number of lines necessary for calling a
          function unless there is a specific readability problem. Some find that formatting with strictly
          one argument on each line is more readable and simplifies editing of the arguments. However,
          we prioritize for the reader over the ease of editing arguments, and most readability problems
          are better addressed with the following techniques.</p>

        <p>If having multiple arguments in a single line decreases readability due to the complexity or
          confusing nature of the expressions that make up some arguments, try creating variables that
          capture those arguments in a descriptive name:</p>
        <pre>int my_heuristic = scores[x] * y + bases[x];
bool result = DoSomething(my_heuristic, x, y, z);
</pre>

        <p>Or put the confusing argument on its own line with an explanatory comment:</p>
        <pre>bool result = DoSomething(scores[x] * y + bases[x],  // Score heuristic.
                          x, y, z);
</pre>

        <p>If there is still a case where one argument is significantly more readable on its own line, then
          put it on its own line. The decision should be specific to the argument which is made more
          readable rather than a general policy.</p>

        <p>Sometimes arguments form a structure that is important for readability. In those cases, feel
          free to format the arguments according to that structure:</p>
        <pre>// Transform the widget by a 3x3 matrix.
my_widget.Transform(x1, x2, x3,
                    y1, y2, y3,
                    z1, z2, z3);
</pre>

      </div>

      <h3 id="Braced_Initializer_List_Format" style="left: -46px; position: relative;">Braced Initializer List Format
        <a href="https://google.github.io/styleguide/cppguide.html#Braced_Initializer_List_Format"
          alt="link to Braced_Initializer_List_Format">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Braced_Initializer_List_Format"
          alt="link to Braced_Initializer_List_Format">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Format a
          <a href="https://google.github.io/styleguide/cppguide.html#Braced_Initializer_List">braced initializer list</a>
          exactly like you would format a function call in its place.</p>
      </div>

      <div class="stylebody">

        <p>If the braced list follows a name (e.g. a type or variable name), format as if the
          <code>{}</code> were the parentheses of a function call with that name. If there is no name, assume a zero-length
          name.</p>

        <pre>// Examples of braced init list on a single line.
return {foo, bar};
functioncall({foo, bar});
std::pair&lt;int, int&gt; p{foo, bar};

// When you have to wrap.
SomeFunction(
    {"assume a zero-length name before {"},
    some_other_function_parameter);
SomeType variable{
    some, other, values,
    {"assume a zero-length name before {"},
    SomeOtherType{
        "Very long string requiring the surrounding breaks.",
        some, other values},
    SomeOtherType{"Slightly shorter string",
                  some, other, values}};
SomeType variable{
    "This is too long to fit all in one line"};
MyType m = {  // Here, you could also break before {.
    superlongvariablename1,
    superlongvariablename2,
    {short, interior, list},
    {interiorwrappinglist,
     interiorwrappinglist2}};
</pre>

      </div>

      <h3 id="Conditionals" style="left: -46px; position: relative;">Conditionals
        <a href="https://google.github.io/styleguide/cppguide.html#Conditionals" alt="link to Conditionals">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Conditionals"
          alt="link to Conditionals">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Prefer no spaces inside parentheses. The
          <code>if</code> and
          <code>else</code> keywords belong on separate lines.</p>
      </div>

      <div class="stylebody">

        <p>There are two acceptable formats for a basic conditional statement. One includes spaces between
          the parentheses and the condition, and one does not.</p>

        <p>The most common form is without spaces. Either is fine, but
          <em>be consistent</em>. If you are modifying a file, use the format that is already present. If
          you are writing new code, use the format that the other files in that directory or project
          use. If in doubt and you have no personal preference, do not add the spaces.</p>

        <pre>if (condition) {  // no spaces inside parentheses
  ...  // 2 space indent.
} else if (...) {  // The else goes on the same line as the closing brace.
  ...
} else {
  ...
}
</pre>

        <p>If you prefer you may add spaces inside the parentheses:
        </p>

        <pre>if ( condition ) {  // spaces inside parentheses - rare
  ...  // 2 space indent.
} else {  // The else goes on the same line as the closing brace.
  ...
}
</pre>

        <p>Note that in all cases you must have a space between the
          <code>if</code> and the open parenthesis. You must also have a space between the close parenthesis and the
          curly brace, if you're using one.</p>

        <pre class="badcode">if(condition) {   // Bad - space missing after IF.
if (condition){   // Bad - space missing before {.
if(condition){    // Doubly bad.
</pre>

        <pre>if (condition) {  // Good - proper space after IF and before {.
</pre>

        <p>Short conditional statements may be written on one line if this enhances readability. You may
          use this only when the line is brief and the statement does not use the
          <code>else</code> clause.</p>

        <pre>if (x == kFoo) return new Foo();
if (x == kBar) return new Bar();
</pre>

        <p>This is not allowed when the if statement has an
          <code>else</code>:</p>

        <pre class="badcode">// Not allowed - IF statement on one line when there is an ELSE clause
if (x) DoThis();
else DoThat();
</pre>

        <p>In general, curly braces are not required for single-line statements, but they are allowed if
          you like them; conditional or loop statements with complex conditions or statements may be
          more readable with curly braces. Some projects require that an
          <code>if</code> must always always have an accompanying brace.
        </p>

        <pre>if (condition)
  DoSomething();  // 2 space indent.

if (condition) {
  DoSomething();  // 2 space indent.
}
</pre>

        <p>However, if one part of an
          <code>if</code>-
          <code>else</code> statement uses curly braces, the other part must too:</p>

        <pre class="badcode">// Not allowed - curly on IF but not ELSE
if (condition) {
  foo;
} else
  bar;

// Not allowed - curly on ELSE but not IF
if (condition)
  foo;
else {
  bar;
}
</pre>

        <pre>// Curly braces around both IF and ELSE required because
// one of the clauses used braces.
if (condition) {
  foo;
} else {
  bar;
}
</pre>

      </div>

      <h3 id="Loops_and_Switch_Statements" style="left: -46px; position: relative;">Loops and Switch Statements
        <a href="https://google.github.io/styleguide/cppguide.html#Loops_and_Switch_Statements"
          alt="link to Loops_and_Switch_Statements">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Loops_and_Switch_Statements"
          alt="link to Loops_and_Switch_Statements">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Switch statements may use braces for blocks. Annotate non-trivial fall-through between cases.
          Braces are optional for single-statement loops. Empty loop bodies should use empty braces or
          <code>continue</code>.</p>
      </div>

      <div class="stylebody">

        <p>
          <code>case</code> blocks in
          <code>switch</code> statements can have curly braces or not, depending on your preference. If you do include curly
          braces they should be placed as shown below.</p>

        <p>If not conditional on an enumerated value, switch statements should always have a
          <code>default</code> case (in the case of an enumerated value, the compiler will warn you if any values are not
          handled). If the default case should never execute, simply
          <code>assert</code>:</p>



        <div>
          <pre>switch (var) {
  case 0: {  // 2 space indent
    ...      // 4 space indent
    break;
  }
  case 1: {
    ...
    break;
  }
  default: {
    assert(false);
  }
}
</pre>
        </div>





        <p> Braces are optional for single-statement loops.</p>

        <pre>for (int i = 0; i &lt; kSomeNumber; ++i)
  printf("I love you\n");

for (int i = 0; i &lt; kSomeNumber; ++i) {
  printf("I take it back\n");
}
</pre>


        <p>Empty loop bodies should use an empty pair of braces or
          <code>continue</code>, but not a single semicolon.</p>

        <pre>while (condition) {
  // Repeat test until it returns false.
}
for (int i = 0; i &lt; kSomeNumber; ++i) {}  // Good - one newline is also OK.
while (condition) continue;  // Good - continue indicates no logic.
</pre>

        <pre class="badcode">while (condition);  // Bad - looks like part of do/while loop.
</pre>

      </div>

      <h3 id="Pointer_and_Reference_Expressions" style="left: -46px; position: relative;">Pointer and Reference Expressions
        <a href="https://google.github.io/styleguide/cppguide.html#Pointer_and_Reference_Expressions"
          alt="link to Pointer_and_Reference_Expressions">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Pointer_and_Reference_Expressions"
          alt="link to Pointer_and_Reference_Expressions">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>No spaces around period or arrow. Pointer operators do not have trailing spaces.</p>
      </div>

      <div class="stylebody">

        <p>The following are examples of correctly-formatted pointer and reference expressions:</p>

        <pre>x = *p;
p = &amp;x;
x = r.y;
x = r-&gt;y;
</pre>

        <p>Note that:</p>

        <ul>
          <li>There are no spaces around the period or arrow when accessing a member.</li>

          <li>Pointer operators have no space after the
            <code>*</code> or
            <code>&amp;</code>.</li>
        </ul>

        <p>When declaring a pointer variable or argument, you may place the asterisk adjacent to either
          the type or to the variable name:</p>

        <pre>// These are fine, space preceding.
char *c;
const string &amp;str;

// These are fine, space following.
char* c;
const string&amp; str;
</pre> It is allowed (if unusual) to declare multiple variables in the same declaration, but it is
        disallowed if any of those have pointer or reference decorations. Such declarations are easily
        misread.
        <pre>// Fine if helpful for readability.
int x, y;
</pre>
        <pre class="badcode">int x, *y;  // Disallowed - no &amp; or * in multiple declaration
char * c;  // Bad - spaces on both sides of *
const string &amp; str;  // Bad - spaces on both sides of &amp;
</pre>

        <p>You should do this consistently within a single file, so, when modifying an existing file, use
          the style in that file.</p>

      </div>

      <h3 id="Boolean_Expressions" style="left: -46px; position: relative;">Boolean Expressions
        <a href="https://google.github.io/styleguide/cppguide.html#Boolean_Expressions"
          alt="link to Boolean_Expressions">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Boolean_Expressions"
          alt="link to Boolean_Expressions">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>When you have a boolean expression that is longer than the
          <a href="https://google.github.io/styleguide/cppguide.html#Line_Length">standard line length</a>, be consistent in how you break up the lines.</p>
      </div>

      <div class="stylebody">

        <p>In this example, the logical AND operator is always at the end of the lines:</p>

        <pre>if (this_one_thing &gt; this_other_thing &amp;&amp;
    a_third_thing == a_fourth_thing &amp;&amp;
    yet_another &amp;&amp; last_one) {
  ...
}
</pre>

        <p>Note that when the code wraps in this example, both of the
          <code>&amp;&amp;</code> logical AND operators are at the end of the line. This is more common in Google code, though
          wrapping all operators at the beginning of the line is also allowed. Feel free to insert extra
          parentheses judiciously because they can be very helpful in increasing readability when used
          appropriately. Also note that you should always use the punctuation operators, such as
          <code>&amp;&amp;</code> and
          <code>~</code>, rather than the word operators, such as
          <code>and</code> and
          <code>compl</code>.</p>

      </div>

      <h3 id="Return_Values" style="left: -46px; position: relative;">Return Values
        <a href="https://google.github.io/styleguide/cppguide.html#Return_Values" alt="link to Return_Values">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Return_Values"
          alt="link to Return_Values">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Do not needlessly surround the
          <code>return</code> expression with parentheses.</p>
      </div>

      <div class="stylebody">

        <p>Use parentheses in
          <code>return expr;</code> only where you would use them in
          <code>x = expr;</code>.</p>

        <pre>return result;                  // No parentheses in the simple case.
// Parentheses OK to make a complex expression more readable.
return (some_long_condition &amp;&amp;
        another_condition);
</pre>

        <pre class="badcode">return (value);                // You wouldn't write var = (value);
return(result);                // return is not a function!
</pre>

      </div>



      <h3 id="Variable_and_Array_Initialization" style="left: -46px; position: relative;">Variable and Array Initialization
        <a href="https://google.github.io/styleguide/cppguide.html#Variable_and_Array_Initialization"
          alt="link to Variable_and_Array_Initialization">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Variable_and_Array_Initialization"
          alt="link to Variable_and_Array_Initialization">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Your choice of
          <code>=</code>,
          <code>()</code>, or
          <code>{}</code>.</p>
      </div>

      <div class="stylebody">

        <p>You may choose between
          <code>=</code>,
          <code>()</code>, and
          <code>{}</code>; the following are all correct:</p>

        <pre>int x = 3;
int x(3);
int x{3};
string name = "Some Name";
string name("Some Name");
string name{"Some Name"};
</pre>

        <p>Be careful when using a braced initialization list
          <code>{...}</code> on a type with an
          <code>std::initializer_list</code> constructor. A nonempty
          <i>braced-init-list</i> prefers the
          <code>std::initializer_list</code> constructor whenever possible. Note that empty braces
          <code>{}</code> are special, and will call a default constructor if available. To force the non-
          <code>std::initializer_list</code> constructor, use parentheses instead of braces.</p>

        <pre>std::vector&lt;int&gt; v(100, 1);  // A vector of 100 1s.
std::vector&lt;int&gt; v{100, 1};  // A vector of 100, 1.
</pre>

        <p>Also, the brace form prevents narrowing of integral types. This can prevent some types of programming
          errors.
        </p>

        <pre>int pi(3.14);  // OK -- pi == 3.
int pi{3.14};  // Compile error: narrowing conversion.
</pre>

      </div>

      <h3 id="Preprocessor_Directives" style="left: -46px; position: relative;">Preprocessor Directives
        <a href="https://google.github.io/styleguide/cppguide.html#Preprocessor_Directives"
          alt="link to Preprocessor_Directives">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Preprocessor_Directives"
          alt="link to Preprocessor_Directives">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>The hash mark that starts a preprocessor directive should always be at the beginning of the line.</p>
      </div>

      <div class="stylebody">

        <p>Even when preprocessor directives are within the body of indented code, the directives should
          start at the beginning of the line.</p>

        <pre>// Good - directives at beginning of line
  if (lopsided_score) {
#if DISASTER_PENDING      // Correct -- Starts at beginning of line
    DropEverything();
# if NOTIFY               // OK but not required -- Spaces after #
    NotifyClient();
# endif
#endif
    BackToNormal();
  }
</pre>

        <pre class="badcode">// Bad - indented directives
  if (lopsided_score) {
    #if DISASTER_PENDING  // Wrong!  The "#if" should be at beginning of line
    DropEverything();
    #endif                // Wrong!  Do not indent "#endif"
    BackToNormal();
  }
</pre>

      </div>

      <h3 id="Class_Format" style="left: -46px; position: relative;">Class Format
        <a href="https://google.github.io/styleguide/cppguide.html#Class_Format" alt="link to Class_Format">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Class_Format"
          alt="link to Class_Format">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Sections in
          <code>public</code>,
          <code>protected</code> and
          <code>private</code> order, each indented one space.</p>
      </div>

      <div class="stylebody">

        <p>The basic format for a class definition (lacking the comments, see
          <a href="https://google.github.io/styleguide/cppguide.html#Class_Comments">Class Comments
          </a> for a discussion of what comments are needed) is:</p>

        <pre>class MyClass : public OtherClass {
 public:      // Note the 1 space indent!
  MyClass();  // Regular 2 space indent.
  explicit MyClass(int var);
  ~MyClass() {}

  void SomeFunction();
  void SomeFunctionThatDoesNothing() {
  }

  void set_some_var(int var) { some_var_ = var; }
  int some_var() const { return some_var_; }

 private:
  bool SomeInternalFunction();

  int some_var_;
  int some_other_var_;
};
</pre>

        <p>Things to note:</p>

        <ul>
          <li>Any base class name should be on the same line as the subclass name, subject to the 80-column
            limit.</li>

          <li>The
            <code>public:</code>,
            <code>protected:</code>, and
            <code>private:</code> keywords should be indented one space.</li>

          <li>Except for the first instance, these keywords should be preceded by a blank line. This rule
            is optional in small classes.</li>

          <li>Do not leave a blank line after these keywords.
          </li>

          <li>The
            <code>public</code> section should be first, followed by the
            <code>protected</code> and finally the
            <code>private</code> section.</li>

          <li>See
            <a href="https://google.github.io/styleguide/cppguide.html#Declaration_Order">Declaration Order
            </a> for rules on ordering declarations within each of these sections.</li>
        </ul>

      </div>

      <h3 id="Constructor_Initializer_Lists" style="left: -46px; position: relative;">Constructor Initializer Lists
        <a href="https://google.github.io/styleguide/cppguide.html#Constructor_Initializer_Lists"
          alt="link to Constructor_Initializer_Lists">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Constructor_Initializer_Lists"
          alt="link to Constructor_Initializer_Lists">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Constructor initializer lists can be all on one line or with subsequent lines indented four spaces.</p>
      </div>

      <div class="stylebody">

        <p>The acceptable formats for initializer lists are:</p>

        <pre>// When everything fits on one line:
MyClass::MyClass(int var) : some_var_(var) {
  DoSomething();
}

// If the signature and initializer list are not all on one line,
// you must wrap before the colon and indent 4 spaces:
MyClass::MyClass(int var)
    : some_var_(var), some_other_var_(var + 1) {
  DoSomething();
}

// When the list spans multiple lines, put each member on its own line
// and align them:
MyClass::MyClass(int var)
    : some_var_(var),             // 4 space indent
      some_other_var_(var + 1) {  // lined up
  DoSomething();
}

// As with any other code block, the close curly can be on the same
// line as the open curly, if it fits.
MyClass::MyClass(int var)
    : some_var_(var) {}
</pre>

      </div>

      <h3 id="Namespace_Formatting" style="left: -46px; position: relative;">Namespace Formatting
        <a href="https://google.github.io/styleguide/cppguide.html#Namespace_Formatting"
          alt="link to Namespace_Formatting">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Namespace_Formatting"
          alt="link to Namespace_Formatting">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>The contents of namespaces are not indented.</p>
      </div>

      <div class="stylebody">

        <p>
          <a href="https://google.github.io/styleguide/cppguide.html#Namespaces">Namespaces</a> do not add an extra level of indentation. For example, use:</p>

        <pre>namespace {

void foo() {  // Correct.  No extra indentation within namespace.
  ...
}

}  // namespace
</pre>

        <p>Do not indent within a namespace:</p>

        <pre class="badcode">namespace {

  // Wrong.  Indented when it should not be.
  void foo() {
    ...
  }

}  // namespace
</pre>

        <p>When declaring nested namespaces, put each namespace on its own line.</p>

        <pre>namespace foo {
namespace bar {
</pre>

      </div>

      <h3 id="Horizontal_Whitespace" style="left: -46px; position: relative;">Horizontal Whitespace
        <a href="https://google.github.io/styleguide/cppguide.html#Horizontal_Whitespace"
          alt="link to Horizontal_Whitespace">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Horizontal_Whitespace"
          alt="link to Horizontal_Whitespace">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Use of horizontal whitespace depends on location. Never put trailing whitespace at the end of
          a line.</p>
      </div>

      <div class="stylebody">

        <h4 class="stylepoint_subsection">General</h4>

        <pre>void f(bool b) {  // Open braces should always have a space before them.
  ...
int i = 0;  // Semicolons usually have no space before them.
// Spaces inside braces for braced-init-list are optional.  If you use them,
// put them on both sides!
int x[] = { 0 };
int x[] = {0};

// Spaces around the colon in inheritance and initializer lists.
class Foo : public Bar {
 public:
  // For inline function implementations, put spaces between the braces
  // and the implementation itself.
  Foo(int b) : Bar(), baz_(b) {}  // No spaces inside empty braces.
  void Reset() { baz_ = 0; }  // Spaces separating braces from implementation.
  ...
</pre>

        <p>Adding trailing whitespace can cause extra work for others editing the same file, when they merge,
          as can removing existing trailing whitespace. So: Don't introduce trailing whitespace. Remove
          it if you're already changing that line, or do it in a separate clean-up operation (preferably
          when no-one else is working on the file).</p>

        <h4 class="stylepoint_subsection">Loops and Conditionals</h4>

        <pre>if (b) {          // Space after the keyword in conditions and loops.
} else {          // Spaces around else.
}
while (test) {}   // There is usually no space inside parentheses.
switch (i) {
for (int i = 0; i &lt; 5; ++i) {
// Loops and conditions may have spaces inside parentheses, but this
// is rare.  Be consistent.
switch ( i ) {
if ( test ) {
for ( int i = 0; i &lt; 5; ++i ) {
// For loops always have a space after the semicolon.  They may have a space
// before the semicolon, but this is rare.
for ( ; i &lt; 5 ; ++i) {
  ...

// Range-based for loops always have a space before and after the colon.
for (auto x : counts) {
  ...
}
switch (i) {
  case 1:         // No space before colon in a switch case.
    ...
  case 2: break;  // Use a space after a colon if there's code after it.
</pre>

        <h4 class="stylepoint_subsection">Operators</h4>

        <pre>// Assignment operators always have spaces around them.
x = 0;

// Other binary operators usually have spaces around them, but it's
// OK to remove spaces around factors.  Parentheses should have no
// internal padding.
v = w * x + y / z;
v = w*x + y/z;
v = w * (x + z);

// No spaces separating unary operators and their arguments.
x = -5;
++x;
if (x &amp;&amp; !y)
  ...
</pre>

        <h4 class="stylepoint_subsection">Templates and Casts</h4>

        <pre>// No spaces inside the angle brackets (&lt; and &gt;), before
// &lt;, or between &gt;( in a cast
std::vector&lt;string&gt; x;
y = static_cast&lt;char*&gt;(x);

// Spaces between type and pointer are OK, but be consistent.
std::vector&lt;char *&gt; x;
</pre>

      </div>

      <h3 id="Vertical_Whitespace" style="left: -46px; position: relative;">Vertical Whitespace
        <a href="https://google.github.io/styleguide/cppguide.html#Vertical_Whitespace"
          alt="link to Vertical_Whitespace">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Vertical_Whitespace"
          alt="link to Vertical_Whitespace">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h3>

      <div class="summary">
        <p>Minimize use of vertical whitespace.</p>
      </div>

      <div class="stylebody">

        <p>This is more a principle than a rule: don't use blank lines when you don't have to. In particular,
          don't put more than one or two blank lines between functions, resist starting functions with
          a blank line, don't end functions with a blank line, and be discriminating with your use of
          blank lines inside functions.</p>

        <p>The basic principle is: The more code that fits on one screen, the easier it is to follow and
          understand the control flow of the program. Of course, readability can suffer from code being
          too dense as well as too spread out, so use your judgement. But in general, minimize use of
          vertical whitespace.</p>

        <p>Some rules of thumb to help when blank lines may be useful:
        </p>

        <ul>
          <li>Blank lines at the beginning or end of a function very rarely help readability.</li>

          <li>Blank lines inside a chain of if-else blocks may well help readability.</li>
        </ul>

      </div>

      <h2 id="Exceptions_to_the_Rules" style="left: -46px; position: relative;">Exceptions to the Rules
        <a href="https://google.github.io/styleguide/cppguide.html#Exceptions_to_the_Rules"
          alt="link to Exceptions_to_the_Rules">
          <img src="./Google_C++_Style_Guide_files/link.png" width="21" height="21" style="float:left;position:relative;bottom:5px;">
        </a>
        <a href="file:///C:/Users/BPiln/Code/hyped/styleguide/Google_C++_Style_Guide.html#Exceptions_to_the_Rules"
          alt="link to Exceptions_to_the_Rules">
          <img src="file:///C:/Users/BPiln/Code/hyped/styleguide/include/link.png" width="21" height="21"
            style="float:left;position:relative;bottom:5px;">
        </a>
      </h2>

      <p>The coding conventions described above are mandatory. However, like all good rules, these sometimes
        have exceptions, which we discuss here.</p>













      <h2 class="ignoreLink">Parting Words</h2>

      <p>Use common sense and
        <em>BE CONSISTENT</em>.</p>

      <p>If you are editing code, take a few minutes to look at the code around you and determine its style.
        If they use spaces around their
        <code>if</code> clauses, you should, too. If their comments have little boxes of stars around them, make your
        comments have little boxes of stars around them too.</p>

      <p>The point of having style guidelines is to have a common vocabulary of coding so people can concentrate
        on what you are saying, rather than on how you are saying it. We present global style rules here
        so people know the vocabulary. But local style is also important. If code you add to a file looks
        drastically different from the existing code around it, the discontinuity throws readers out
        of their rhythm when they go to read it. Try to avoid this.</p>



      <p>OK, enough writing about writing code; the code itself is much more interesting. Have fun!</p>

      <hr>

    </div>
  </div>


</body>

</html>